{"version":3,"sources":["../node_modules/react-tooltip/node_modules/uuid/dist/esm-browser/rng.js","../node_modules/react-tooltip/node_modules/uuid/dist/esm-browser/bytesToUuid.js","../node_modules/react-tooltip/node_modules/uuid/dist/esm-browser/v4.js","../../src/constant.js","../../src/decorators/staticMethods.js","../../src/decorators/customEvent.js","../../src/decorators/bodyMode.js","../../src/utils/getPosition.js","../../src/utils/getTipContent.js","../../src/utils/aria.js","../../src/utils/nodeListToArray.js","../../src/decorators/defaultStyles.js","../../src/decorators/styler.js","../../src/decorators/trackRemoval.js","../../src/index.js","../../src/decorators/windowListener.js","../../src/decorators/isCapture.js","../../src/decorators/getEffect.js","../../src/utils/uuid.js","../node_modules/lodash/sum.js","vanilla/components/alignment.ts","vanilla/components/utils.ts","vanilla/components/counter.ts","vanilla/components/eventStore.ts","vanilla/components/vector1d.ts","vanilla/components/dragHandler.ts","vanilla/components/limit.ts","vanilla/components/scrollBody.ts","vanilla/components/scrollBounds.ts","vanilla/components/scrollContain.ts","vanilla/components/scrollLooper.ts","vanilla/components/scrollProgress.ts","vanilla/components/scrollSnap.ts","vanilla/components/scrollTarget.ts","vanilla/components/slideLooper.ts","vanilla/components/slideFocus.ts","vanilla/components/translate.ts","vanilla/components/engine.ts","vanilla/components/pxToPercent.ts","vanilla/components/direction.ts","vanilla/components/axis.ts","vanilla/components/slideSizes.ts","vanilla/components/scrollLimit.ts","vanilla/components/animation.ts","vanilla/components/scrollTo.ts","vanilla/components/slidesInView.ts","vanilla/components/dragTracker.ts","vanilla/components/options.ts","vanilla/index.ts","vanilla/components/eventEmitter.ts","vanilla/components/optionsPseudo.ts","react/index.ts","react/utils.ts","../node_modules/lodash/_baseSum.js"],"names":["getRandomValues","crypto","bind","msCrypto","rnds8","Uint8Array","rng","Error","byteToHex","i","toString","substr","bytesToUuid","buf","offset","bth","join","v4","options","Array","rnds","random","ii","HIDE","REBUILD","SHOW","dispatchGlobalEvent","eventName","opts","window","event","detail","document","checkStatus","show","this","id","isCapture","e","currentItem","hideTooltip","setUntargetItems","getTargetArray","targetArray","currentTarget","customListeners","set","target","map","Object","configurable","value","get","bodyListener","respectEffect","customEvent","tip","forId","isCustomEvent","isTargetBelongsToTooltip","getEffect","proxy","makeProxy","callback","findCustomEvents","dataAttribute","events","getBody","getDimensions","tipWidth","tipHeight","targetWidth","targetHeight","getCurrentOffset","mouseX","mouseY","defaultOffset","getDefaultPosition","calculateOffset","extraOffsetX","extraOffsetY","windowWidth","windowHeight","getParent","parentTop","parentLeft","getTipOffsetLeft","place","offsetX","getTipOffsetTop","offsetY","outsideRight","p","getTipOffsetRight","outsideBottom","getTipOffsetBottom","outside","outsideLeft","outsideTop","inside","placesList","insideList","isNewState","shouldUpdatePlace","desiredPlace","newPlace","newState","position","left","parseInt","top","node","height","width","effect","boundingClientRect","targetTop","targetLeft","clientY","l","r","t","b","bottom","disToMouse","right","JSON","key","currentParent","computedStyle","children","getContent","regexp","multiline","className","parseAria","props","ariaObj","prop","test","length","nodeList","fill","index","defaultColors","dark","text","background","border","arrow","success","warning","error","info","light","generateTooltipStyle","uuid","customColors","type","hasBorder","colors","textColor","backgroundColor","borderColor","arrowColor","generateStyle","getDefaultPopupColors","getPopupColors","ReactTooltip","CONSTANT","hasTarget","staticMethods","windowListener","ele","eventOff","dataEvent","dataEventOff","customListener","dataEffect","possibleCustomEvents","possibleCustomEventsOff","body","customEvents","customEventsOff","listeners","bodyModeListeners","targetEventOff","bodyMode","trackRemoval","extraClass","html","delayHide","delayShow","currentEvent","ariaProps","isEmptyTip","disable","originTooltip","isMultiline","PropTypes","insecure","class","delayUpdate","globalEventOff","afterShow","afterHide","overridePosition","scrollHide","resizeHide","wrapper","clickable","bool","methodArray","method","state","tooltipRef","parentNode","domRoot","style","matches","escaped","selector","nodeListToArray","element","isCaptureMode","content","getTipContent","placeholder","isGlobalCall","switchToSolid","result","getPosition","reshowDelay","self","updateState","setInterval","setTimeout","eventTarget","delayTime","isInvisible","clearTimeout","isScroll","isMyElement","resetState","isVisible","setState","clearInterval","Boolean","color","tooltipClass","hasCustomColors","Wrapper","wrapperClassName","htmlContent","ref","data-id","dangerouslySetInnerHTML","__html","nextProps","prevState","newAriaProps","React","Component","MutationObserver","observer","mutations","m1","mutation","m2","childList","subtree","baseSum","require","identity","module","exports","array","Alignment","align","viewSize","predefined","start","center","end","measure","Number","mathSign","n","Math","deltaAbs","valueB","valueA","groupArray","size","groups","arrayKeys","arrayLast","lastIndex","removeClass","cl","addClass","Counter","limit","loop","min","max","withinLimit","counter","add","sign","clone","EventStore","removeAll","remove","Vector1D","vector","readNumber","divide","multiply","normalize","subtract","DragHandler","axis","direction","rootNode","dragFree","dragTracker","location","animation","scrollTo","scrollBody","scrollTarget","scrollAxis","scroll","crossAxis","focusNodes","startScroll","startCross","dragStartPoint","activationEvents","interactionEvents","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","pointerIsDown","preventScroll","preventClick","isMouse","evt","isMoving","clearPreventClick","isNotFocusNode","name","isFocusNode","preventDefault","addInteractionEvents","up","moveScroll","moveCross","diffScroll","diffCross","diff","rawForce","force","seekNext","currentLocation","destination","next","allowedForce","speedFactor","factorAbs","addActivationEvents","clickAllowed","pointerDown","removeAllEvents","Limit","reachedMin","reachedMax","constrain","reachedAny","removeOffset","ScrollBody","baseMass","roundToTwoDecimals","decimalPoints","pow","roundToDecimals","velocity","acceleration","attraction","attractionDirection","speed","mass","seek","iStart","oStart","magnitude","v","applyForce","settle","hasSettled","update","useBaseMass","useMass","useBaseSpeed","useSpeed","ScrollBounds","disabled","shouldConstrain","friction","diffToTarget","toggleActive","ScrollContain","contentSize","snaps","snapsAligned","containScroll","scrollBounds","snapsBounded","snapsContained","startSnap","endSnap","findDuplicates","measureContained","ScrollLooper","pxToPercent","shouldLoop","loopDistance","vectors","ScrollProgress","scrollLength","ScrollSnap","alignment","containerRect","slideRects","slidesToScroll","startEdge","endEdge","rect","groupedSnaps","g","alignments","rects","measureSizes","snap","measureAligned","ScrollTarget","indexCurrent","scrollSnaps","targetVector","t1","t2","t3","minDistance","shortest","byDistance","targetSnap","distance","scrollSnap","shortcut","diffToSnap","d1","d2","ascDiffsToSnaps","findTargetSnap","findTargetIndex","reachedBound","byIndex","SlideLooper","slideSizesWithGaps","slidesInView","scrollLocation","ascItems","descItems","loopPoints","gap","findLoopPoints","slidesInGap","startPoints","endPoints","indexes","a","removeSlideSizes","remainingGap","isStartEdge","edge","slideBounds","initial","altered","point","getTarget","canLoop","clear","slides","loopPoint","SlideFocus","eventStore","lastTabPressTime","Date","selectedIndex","Translate","container","containerStyle","translate","to","Engine","root","viewInPx","contentDirection","startIndex","inViewThreshold","slide","applyTo","Direction","cross","measureSize","Axis","totalPercent","sizesInPx","slideSizes","isLast","endGap","parseFloat","SlideSizes","measureLimit","ScrollLimit","indexPrevious","slideIndexes","animationFrame","active","cb","proceed","ifAnimating","stop","Animation","engine","settled","startLocation","loopVectors","distanceDiff","indexDiff","targetIndex","ScrollTo","threshold","findSlideBounds","thresholds","s","check","slideBound","list","SlidesInView","dragHandler","coords","x","y","startDrag","diffDrag","lastDrag","pointValue","trackPoints","lastMoveTime","c","readPoint","pointerMove","nowTime","diffTime","pointerUp","currentPoint","DragTracker","scrollLooper","scrollProgress","slideFocus","slideLooper","defaultOptions","draggable","draggableClass","draggingClass","selectedClass","EmblaCarousel","emit","getListeners","off","on","EventEmitter","debouncedResize","time","timeout","debounce","sliderRoot","rootNodeSize","reActivate","reInit","activated","sliderContainer","optionsPseudo","psuedoString","OptionsPseudo","setupElements","deActivate","activate","toggleSelectedClass","inView","slidesNotInView","notInView","newOptions","selectedScrollSnap","canScrollNext","canScrollPrev","prev","containerNode","dangerouslyGetEngine","destroy","previousScrollSnap","scrollNext","scrollPrev","scrollSnapList","slideNodes","useState","embla","setEmbla","viewport","setViewport","storedOptions","useRef","activeOptions","useMemo","objectA","objectB","useEffect","newEmbla_1","iteratee","current","undefined"],"mappings":"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","file":"static/js/2.9f565b5d.chunk.js","sourcesContent":["// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n// find the complete implementation of crypto (msCrypto) on IE11.\nvar getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);\nvar rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\nexport default function rng() {\n  if (!getRandomValues) {\n    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n  }\n\n  return getRandomValues(rnds8);\n}","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\n  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');\n}\n\nexport default bytesToUuid;","import rng from './rng.js';\nimport bytesToUuid from './bytesToUuid.js';\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof options == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nexport default v4;","export default {\n  GLOBAL: {\n    HIDE: '__react_tooltip_hide_event',\n    REBUILD: '__react_tooltip_rebuild_event',\n    SHOW: '__react_tooltip_show_event'\n  }\n};\n","/**\n * Static methods for react-tooltip\n */\nimport CONSTANT from '../constant';\n\nconst dispatchGlobalEvent = (eventName, opts) => {\n  // Compatible with IE\n  // @see http://stackoverflow.com/questions/26596123/internet-explorer-9-10-11-event-constructor-doesnt-work\n  // @see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n  let event;\n\n  if (typeof window.CustomEvent === 'function') {\n    event = new window.CustomEvent(eventName, { detail: opts });\n  } else {\n    event = document.createEvent('Event');\n    event.initEvent(eventName, false, true, opts);\n  }\n\n  window.dispatchEvent(event);\n};\n\nexport default function(target) {\n  /**\n   * Hide all tooltip\n   * @trigger ReactTooltip.hide()\n   */\n  target.hide = target => {\n    dispatchGlobalEvent(CONSTANT.GLOBAL.HIDE, { target });\n  };\n\n  /**\n   * Rebuild all tooltip\n   * @trigger ReactTooltip.rebuild()\n   */\n  target.rebuild = () => {\n    dispatchGlobalEvent(CONSTANT.GLOBAL.REBUILD);\n  };\n\n  /**\n   * Show specific tooltip\n   * @trigger ReactTooltip.show()\n   */\n  target.show = target => {\n    dispatchGlobalEvent(CONSTANT.GLOBAL.SHOW, { target });\n  };\n\n  target.prototype.globalRebuild = function() {\n    if (this.mount) {\n      this.unbindListener();\n      this.bindListener();\n    }\n  };\n\n  target.prototype.globalShow = function(event) {\n    if (this.mount) {\n      const hasTarget =\n        (event && event.detail && event.detail.target && true) || false;\n      // Create a fake event, specific show will limit the type to `solid`\n      // only `float` type cares e.clientX e.clientY\n      this.showTooltip(\n        { currentTarget: hasTarget && event.detail.target },\n        true\n      );\n    }\n  };\n\n  target.prototype.globalHide = function(event) {\n    if (this.mount) {\n      const hasTarget =\n        (event && event.detail && event.detail.target && true) || false;\n      this.hideTooltip(\n        { currentTarget: hasTarget && event.detail.target },\n        hasTarget\n      );\n    }\n  };\n}\n","/**\n * Custom events to control showing and hiding of tooltip\n *\n * @attributes\n * - `event` {String}\n * - `eventOff` {String}\n */\n\nexport const checkStatus = function(dataEventOff, e) {\n  const { show } = this.state;\n  const { id } = this.props;\n  const isCapture = this.isCapture(e.currentTarget);\n  const currentItem = e.currentTarget.getAttribute('currentItem');\n\n  if (!isCapture) e.stopPropagation();\n  if (show && currentItem === 'true') {\n    if (!dataEventOff) this.hideTooltip(e);\n  } else {\n    e.currentTarget.setAttribute('currentItem', 'true');\n    setUntargetItems(e.currentTarget, this.getTargetArray(id));\n    this.showTooltip(e);\n  }\n};\n\nconst setUntargetItems = function(currentTarget, targetArray) {\n  for (let i = 0; i < targetArray.length; i++) {\n    if (currentTarget !== targetArray[i]) {\n      targetArray[i].setAttribute('currentItem', 'false');\n    } else {\n      targetArray[i].setAttribute('currentItem', 'true');\n    }\n  }\n};\n\nconst customListeners = {\n  id: '9b69f92e-d3fe-498b-b1b4-c5e63a51b0cf',\n  set(target, event, listener) {\n    if (this.id in target) {\n      const map = target[this.id];\n      map[event] = listener;\n    } else {\n      // this is workaround for WeakMap, which is not supported in older browsers, such as IE\n      Object.defineProperty(target, this.id, {\n        configurable: true,\n        value: { [event]: listener }\n      });\n    }\n  },\n  get(target, event) {\n    const map = target[this.id];\n    if (map !== undefined) {\n      return map[event];\n    }\n  }\n};\n\nexport default function(target) {\n  target.prototype.isCustomEvent = function(ele) {\n    const { event } = this.state;\n    return event || !!ele.getAttribute('data-event');\n  };\n\n  /* Bind listener for custom event */\n  target.prototype.customBindListener = function(ele) {\n    const { event, eventOff } = this.state;\n    const dataEvent = ele.getAttribute('data-event') || event;\n    const dataEventOff = ele.getAttribute('data-event-off') || eventOff;\n\n    dataEvent.split(' ').forEach(event => {\n      ele.removeEventListener(event, customListeners.get(ele, event));\n      const customListener = checkStatus.bind(this, dataEventOff);\n      customListeners.set(ele, event, customListener);\n      ele.addEventListener(event, customListener, false);\n    });\n    if (dataEventOff) {\n      dataEventOff.split(' ').forEach(event => {\n        ele.removeEventListener(event, this.hideTooltip);\n        ele.addEventListener(event, this.hideTooltip, false);\n      });\n    }\n  };\n\n  /* Unbind listener for custom event */\n  target.prototype.customUnbindListener = function(ele) {\n    const { event, eventOff } = this.state;\n    const dataEvent = event || ele.getAttribute('data-event');\n    const dataEventOff = eventOff || ele.getAttribute('data-event-off');\n\n    ele.removeEventListener(dataEvent, customListeners.get(ele, event));\n    if (dataEventOff) ele.removeEventListener(dataEventOff, this.hideTooltip);\n  };\n}\n","/**\n * Util method to get effect\n */\nimport { checkStatus } from './customEvent';\n\nconst makeProxy = e => {\n  const proxy = {};\n  for (const key in e) {\n    if (typeof e[key] === 'function') {\n      proxy[key] = e[key].bind(e);\n    } else {\n      proxy[key] = e[key];\n    }\n  }\n  return proxy;\n};\n\nconst bodyListener = function(callback, options, e) {\n  const { respectEffect = false, customEvent = false } = options;\n  const { id } = this.props;\n\n  const tip = e.target.getAttribute('data-tip') || null;\n  const forId = e.target.getAttribute('data-for') || null;\n\n  const target = e.target;\n  if (this.isCustomEvent(target) && !customEvent) {\n    return;\n  }\n\n  const isTargetBelongsToTooltip =\n    (id == null && forId == null) || forId === id;\n\n  if (\n    tip != null &&\n    (!respectEffect || this.getEffect(target) === 'float') &&\n    isTargetBelongsToTooltip\n  ) {\n    const proxy = makeProxy(e);\n    proxy.currentTarget = target;\n    callback(proxy);\n  }\n};\n\nconst findCustomEvents = (targetArray, dataAttribute) => {\n  const events = {};\n  targetArray.forEach(target => {\n    const event = target.getAttribute(dataAttribute);\n    if (event) event.split(' ').forEach(event => (events[event] = true));\n  });\n\n  return events;\n};\n\nconst getBody = () => document.getElementsByTagName('body')[0];\n\nexport default function(target) {\n  target.prototype.isBodyMode = function() {\n    return !!this.props.bodyMode;\n  };\n\n  target.prototype.bindBodyListener = function(targetArray) {\n    const {\n      event,\n      eventOff,\n      possibleCustomEvents,\n      possibleCustomEventsOff\n    } = this.state;\n    const body = getBody();\n\n    const customEvents = findCustomEvents(targetArray, 'data-event');\n    const customEventsOff = findCustomEvents(targetArray, 'data-event-off');\n\n    if (event != null) customEvents[event] = true;\n    if (eventOff != null) customEventsOff[eventOff] = true;\n    possibleCustomEvents\n      .split(' ')\n      .forEach(event => (customEvents[event] = true));\n    possibleCustomEventsOff\n      .split(' ')\n      .forEach(event => (customEventsOff[event] = true));\n\n    this.unbindBodyListener(body);\n\n    const listeners = (this.bodyModeListeners = {});\n    if (event == null) {\n      listeners.mouseover = bodyListener.bind(this, this.showTooltip, {});\n      listeners.mousemove = bodyListener.bind(this, this.updateTooltip, {\n        respectEffect: true\n      });\n      listeners.mouseout = bodyListener.bind(this, this.hideTooltip, {});\n    }\n\n    for (const event in customEvents) {\n      listeners[event] = bodyListener.bind(\n        this,\n        e => {\n          const targetEventOff =\n            e.currentTarget.getAttribute('data-event-off') || eventOff;\n          checkStatus.call(this, targetEventOff, e);\n        },\n        { customEvent: true }\n      );\n    }\n    for (const event in customEventsOff) {\n      listeners[event] = bodyListener.bind(this, this.hideTooltip, {\n        customEvent: true\n      });\n    }\n    for (const event in listeners) {\n      body.addEventListener(event, listeners[event]);\n    }\n  };\n\n  target.prototype.unbindBodyListener = function(body) {\n    body = body || getBody();\n\n    const listeners = this.bodyModeListeners;\n    for (const event in listeners) {\n      body.removeEventListener(event, listeners[event]);\n    }\n  };\n}\n","/**\n * Calculate the position of tooltip\n *\n * @params\n * - `e` {Event} the event of current mouse\n * - `target` {Element} the currentTarget of the event\n * - `node` {DOM} the react-tooltip object\n * - `place` {String} top / right / bottom / left\n * - `effect` {String} float / solid\n * - `offset` {Object} the offset to default position\n *\n * @return {Object}\n * - `isNewState` {Bool} required\n * - `newState` {Object}\n * - `position` {Object} {left: {Number}, top: {Number}}\n */\nexport default function(e, target, node, place, desiredPlace, effect, offset) {\n  const { width: tipWidth, height: tipHeight } = getDimensions(node);\n\n  const { width: targetWidth, height: targetHeight } = getDimensions(target);\n\n  const { mouseX, mouseY } = getCurrentOffset(e, target, effect);\n  const defaultOffset = getDefaultPosition(\n    effect,\n    targetWidth,\n    targetHeight,\n    tipWidth,\n    tipHeight\n  );\n  const { extraOffsetX, extraOffsetY } = calculateOffset(offset);\n\n  const windowWidth = window.innerWidth;\n  const windowHeight = window.innerHeight;\n\n  const { parentTop, parentLeft } = getParent(node);\n\n  // Get the edge offset of the tooltip\n  const getTipOffsetLeft = place => {\n    const offsetX = defaultOffset[place].l;\n    return mouseX + offsetX + extraOffsetX;\n  };\n  const getTipOffsetRight = place => {\n    const offsetX = defaultOffset[place].r;\n    return mouseX + offsetX + extraOffsetX;\n  };\n  const getTipOffsetTop = place => {\n    const offsetY = defaultOffset[place].t;\n    return mouseY + offsetY + extraOffsetY;\n  };\n  const getTipOffsetBottom = place => {\n    const offsetY = defaultOffset[place].b;\n    return mouseY + offsetY + extraOffsetY;\n  };\n\n  //\n  // Functions to test whether the tooltip's sides are inside\n  // the client window for a given orientation p\n  //\n  //  _____________\n  // |             | <-- Right side\n  // | p = 'left'  |\\\n  // |             |/  |\\\n  // |_____________|   |_\\  <-- Mouse\n  //      / \\           |\n  //       |\n  //       |\n  //  Bottom side\n  //\n  const outsideLeft = p => getTipOffsetLeft(p) < 0;\n  const outsideRight = p => getTipOffsetRight(p) > windowWidth;\n  const outsideTop = p => getTipOffsetTop(p) < 0;\n  const outsideBottom = p => getTipOffsetBottom(p) > windowHeight;\n\n  // Check whether the tooltip with orientation p is completely inside the client window\n  const outside = p =>\n    outsideLeft(p) || outsideRight(p) || outsideTop(p) || outsideBottom(p);\n  const inside = p => !outside(p);\n\n  const placesList = ['top', 'bottom', 'left', 'right'];\n  const insideList = [];\n  for (let i = 0; i < 4; i++) {\n    const p = placesList[i];\n    if (inside(p)) {\n      insideList.push(p);\n    }\n  }\n\n  let isNewState = false;\n  let newPlace;\n  const shouldUpdatePlace = desiredPlace !== place;\n  if (inside(desiredPlace) && shouldUpdatePlace) {\n    isNewState = true;\n    newPlace = desiredPlace;\n  } else if (insideList.length > 0 && outside(desiredPlace) && outside(place)) {\n    isNewState = true;\n    newPlace = insideList[0];\n  }\n\n  if (isNewState) {\n    return {\n      isNewState: true,\n      newState: { place: newPlace }\n    };\n  }\n\n  return {\n    isNewState: false,\n    position: {\n      left: parseInt(getTipOffsetLeft(place) - parentLeft, 10),\n      top: parseInt(getTipOffsetTop(place) - parentTop, 10)\n    }\n  };\n}\n\nconst getDimensions = node => {\n  const { height, width } = node.getBoundingClientRect();\n  return {\n    height: parseInt(height, 10),\n    width: parseInt(width, 10)\n  };\n};\n\n// Get current mouse offset\nconst getCurrentOffset = (e, currentTarget, effect) => {\n  const boundingClientRect = currentTarget.getBoundingClientRect();\n  const targetTop = boundingClientRect.top;\n  const targetLeft = boundingClientRect.left;\n  const { width: targetWidth, height: targetHeight } = getDimensions(\n    currentTarget\n  );\n\n  if (effect === 'float') {\n    return {\n      mouseX: e.clientX,\n      mouseY: e.clientY\n    };\n  }\n  return {\n    mouseX: targetLeft + targetWidth / 2,\n    mouseY: targetTop + targetHeight / 2\n  };\n};\n\n// List all possibility of tooltip final offset\n// This is useful in judging if it is necessary for tooltip to switch position when out of window\nconst getDefaultPosition = (\n  effect,\n  targetWidth,\n  targetHeight,\n  tipWidth,\n  tipHeight\n) => {\n  let top;\n  let right;\n  let bottom;\n  let left;\n  const disToMouse = 3;\n  const triangleHeight = 2;\n  const cursorHeight = 12; // Optimize for float bottom only, cause the cursor will hide the tooltip\n\n  if (effect === 'float') {\n    top = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: -(tipHeight + disToMouse + triangleHeight),\n      b: -disToMouse\n    };\n    bottom = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: disToMouse + cursorHeight,\n      b: tipHeight + disToMouse + triangleHeight + cursorHeight\n    };\n    left = {\n      l: -(tipWidth + disToMouse + triangleHeight),\n      r: -disToMouse,\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n    right = {\n      l: disToMouse,\n      r: tipWidth + disToMouse + triangleHeight,\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n  } else if (effect === 'solid') {\n    top = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: -(targetHeight / 2 + tipHeight + triangleHeight),\n      b: -(targetHeight / 2)\n    };\n    bottom = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: targetHeight / 2,\n      b: targetHeight / 2 + tipHeight + triangleHeight\n    };\n    left = {\n      l: -(tipWidth + targetWidth / 2 + triangleHeight),\n      r: -(targetWidth / 2),\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n    right = {\n      l: targetWidth / 2,\n      r: tipWidth + targetWidth / 2 + triangleHeight,\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n  }\n\n  return { top, bottom, left, right };\n};\n\n// Consider additional offset into position calculation\nconst calculateOffset = offset => {\n  let extraOffsetX = 0;\n  let extraOffsetY = 0;\n\n  if (Object.prototype.toString.apply(offset) === '[object String]') {\n    offset = JSON.parse(offset.toString().replace(/'/g, '\"'));\n  }\n  for (const key in offset) {\n    if (key === 'top') {\n      extraOffsetY -= parseInt(offset[key], 10);\n    } else if (key === 'bottom') {\n      extraOffsetY += parseInt(offset[key], 10);\n    } else if (key === 'left') {\n      extraOffsetX -= parseInt(offset[key], 10);\n    } else if (key === 'right') {\n      extraOffsetX += parseInt(offset[key], 10);\n    }\n  }\n\n  return { extraOffsetX, extraOffsetY };\n};\n\n// Get the offset of the parent elements\nconst getParent = currentTarget => {\n  let currentParent = currentTarget;\n  while (currentParent) {\n    const computedStyle = window.getComputedStyle(currentParent);\n    // transform and will-change: transform change the containing block\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_Block\n    if (\n      computedStyle.getPropertyValue('transform') !== 'none' ||\n      computedStyle.getPropertyValue('will-change') === 'transform'\n    )\n      break;\n    currentParent = currentParent.parentElement;\n  }\n\n  const parentTop =\n    (currentParent && currentParent.getBoundingClientRect().top) || 0;\n  const parentLeft =\n    (currentParent && currentParent.getBoundingClientRect().left) || 0;\n\n  return { parentTop, parentLeft };\n};\n","/**\n * To get the tooltip content\n * it may comes from data-tip or this.props.children\n * it should support multiline\n *\n * @params\n * - `tip` {String} value of data-tip\n * - `children` {ReactElement} this.props.children\n * - `multiline` {Any} could be Bool(true/false) or String('true'/'false')\n *\n * @return\n * - String or react component\n */\nimport React from 'react';\n\nexport default function(tip, children, getContent, multiline) {\n  if (children) return children;\n  if (getContent !== undefined && getContent !== null) return getContent; // getContent can be 0, '', etc.\n  if (getContent === null) return null; // Tip not exist and children is null or undefined\n\n  const regexp = /<br\\s*\\/?>/;\n  if (!multiline || multiline === 'false' || !regexp.test(tip)) {\n    // No trim(), so that user can keep their input\n    return tip;\n  }\n\n  // Multiline tooltip content\n  return tip.split(regexp).map((d, i) => {\n    return (\n      <span key={i} className=\"multi-line\">\n        {d}\n      </span>\n    );\n  });\n}\n","/**\n * Support aria- and role in ReactTooltip\n *\n * @params props {Object}\n * @return {Object}\n */\nexport function parseAria(props) {\n  const ariaObj = {};\n  Object.keys(props)\n    .filter(prop => {\n      // aria-xxx and role is acceptable\n      return /(^aria-\\w+$|^role$)/.test(prop);\n    })\n    .forEach(prop => {\n      ariaObj[prop] = props[prop];\n    });\n\n  return ariaObj;\n}\n","/**\n * Convert nodelist to array\n * @see https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/core/createArrayFromMixed.js#L24\n * NodeLists are functions in Safari\n */\n\nexport default function(nodeList) {\n  const length = nodeList.length;\n  if (nodeList.hasOwnProperty) {\n    return Array.prototype.slice.call(nodeList);\n  }\n  return new Array(length).fill().map(index => nodeList[index]);\n}\n","/**\n * Default pop-up style values (text color, background color).\n */\nconst defaultColors = {\n  dark: {\n    text: '#fff',\n    background: '#222',\n    border: 'transparent',\n    arrow: '#222'\n  },\n  success: {\n    text: '#fff',\n    background: '#8DC572',\n    border: 'transparent',\n    arrow: '#8DC572'\n  },\n  warning: {\n    text: '#fff',\n    background: '#F0AD4E',\n    border: 'transparent',\n    arrow: '#F0AD4E'\n  },\n  error: {\n    text: '#fff',\n    background: '#BE6464',\n    border: 'transparent',\n    arrow: '#BE6464'\n  },\n  info: {\n    text: '#fff',\n    background: '#337AB7',\n    border: 'transparent',\n    arrow: '#337AB7'\n  },\n  light: {\n    text: '#222',\n    background: '#fff',\n    border: 'transparent',\n    arrow: '#fff'\n  }\n};\n\nexport function getDefaultPopupColors(type) {\n  return defaultColors[type] ? { ...defaultColors[type] } : undefined;\n}\n","import { getDefaultPopupColors } from './defaultStyles';\n\n/**\n * Generates the specific tooltip style for use on render.\n */\nexport function generateTooltipStyle(uuid, customColors, type, hasBorder) {\n  return generateStyle(uuid, getPopupColors(customColors, type, hasBorder));\n}\n\n/**\n * Generates the tooltip style rules based on the element-specified \"data-type\" property.\n */\nfunction generateStyle(uuid, colors) {\n  const textColor = colors.text;\n  const backgroundColor = colors.background;\n  const borderColor = colors.border;\n  const arrowColor = colors.arrow;\n\n  return `\n  \t.${uuid} {\n\t    color: ${textColor};\n\t    background: ${backgroundColor};\n\t    border: 1px solid ${borderColor};\n  \t}\n\n  \t.${uuid}.place-top {\n        margin-top: -10px;\n    }\n    .${uuid}.place-top::before {\n        border-top: 8px solid ${borderColor};\n    }\n    .${uuid}.place-top::after {\n        border-left: 8px solid transparent;\n        border-right: 8px solid transparent;\n        bottom: -6px;\n        left: 50%;\n        margin-left: -8px;\n        border-top-color: ${arrowColor};\n        border-top-style: solid;\n        border-top-width: 6px;\n    }\n\n    .${uuid}.place-bottom {\n        margin-top: 10px;\n    }\n    .${uuid}.place-bottom::before {\n        border-bottom: 8px solid ${borderColor};\n    }\n    .${uuid}.place-bottom::after {\n        border-left: 8px solid transparent;\n        border-right: 8px solid transparent;\n        top: -6px;\n        left: 50%;\n        margin-left: -8px;\n        border-bottom-color: ${arrowColor};\n        border-bottom-style: solid;\n        border-bottom-width: 6px;\n    }\n\n    .${uuid}.place-left {\n        margin-left: -10px;\n    }\n    .${uuid}.place-left::before {\n        border-left: 8px solid ${borderColor};\n    }\n    .${uuid}.place-left::after {\n        border-top: 5px solid transparent;\n        border-bottom: 5px solid transparent;\n        right: -6px;\n        top: 50%;\n        margin-top: -4px;\n        border-left-color: ${arrowColor};\n        border-left-style: solid;\n        border-left-width: 6px;\n    }\n\n    .${uuid}.place-right {\n        margin-left: 10px;\n    }\n    .${uuid}.place-right::before {\n        border-right: 8px solid ${borderColor};\n    }\n    .${uuid}.place-right::after {\n        border-top: 5px solid transparent;\n        border-bottom: 5px solid transparent;\n        left: -6px;\n        top: 50%;\n        margin-top: -4px;\n        border-right-color: ${arrowColor};\n        border-right-style: solid;\n        border-right-width: 6px;\n    }\n  `;\n}\n\nfunction getPopupColors(customColors, type, hasBorder) {\n  const textColor = customColors.text;\n  const backgroundColor = customColors.background;\n  const borderColor = customColors.border;\n  const arrowColor = customColors.arrow\n    ? customColors.arrow\n    : customColors.background;\n\n  const colors = getDefaultPopupColors(type);\n\n  if (textColor) {\n    colors.text = textColor;\n  }\n\n  if (backgroundColor) {\n    colors.background = backgroundColor;\n  }\n\n  if (hasBorder) {\n    if (borderColor) {\n      colors.border = borderColor;\n    } else {\n      colors.border = type === 'light' ? 'black' : 'white';\n    }\n  }\n\n  if (arrowColor) {\n    colors.arrow = arrowColor;\n  }\n\n  return colors;\n}\n","/**\n * Tracking target removing from DOM.\n * It's necessary to hide tooltip when it's target disappears.\n * Otherwise, the tooltip would be shown forever until another target\n * is triggered.\n *\n * If MutationObserver is not available, this feature just doesn't work.\n */\n\n// https://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/\nconst getMutationObserverClass = () => {\n  return (\n    window.MutationObserver ||\n    window.WebKitMutationObserver ||\n    window.MozMutationObserver\n  );\n};\n\nexport default function(target) {\n  target.prototype.bindRemovalTracker = function() {\n    const MutationObserver = getMutationObserverClass();\n    if (MutationObserver == null) return;\n\n    const observer = new MutationObserver(mutations => {\n      for (let m1 = 0; m1 < mutations.length; m1++) {\n        const mutation = mutations[m1];\n        for (let m2 = 0; m2 < mutation.removedNodes.length; m2++) {\n          const element = mutation.removedNodes[m2];\n          if (element === this.state.currentTarget) {\n            this.hideTooltip();\n            return;\n          }\n        }\n      }\n    });\n\n    observer.observe(window.document, { childList: true, subtree: true });\n\n    this.removalTracker = observer;\n  };\n\n  target.prototype.unbindRemovalTracker = function() {\n    if (this.removalTracker) {\n      this.removalTracker.disconnect();\n      this.removalTracker = null;\n    }\n  };\n}\n","/* eslint-disable no-unused-vars, dot-notation */\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\n/* Decorators */\nimport staticMethods from './decorators/staticMethods';\nimport windowListener from './decorators/windowListener';\nimport customEvent from './decorators/customEvent';\nimport isCapture from './decorators/isCapture';\nimport getEffect from './decorators/getEffect';\nimport bodyMode from './decorators/bodyMode';\nimport trackRemoval from './decorators/trackRemoval';\n\n/* Utils */\nimport getPosition from './utils/getPosition';\nimport getTipContent from './utils/getTipContent';\nimport { parseAria } from './utils/aria';\nimport nodeListToArray from './utils/nodeListToArray';\nimport { generateUUID } from './utils/uuid';\n\n/* CSS */\nimport baseCss from './index.scss';\nimport { generateTooltipStyle } from './decorators/styler';\n\n@staticMethods\n@windowListener\n@customEvent\n@isCapture\n@getEffect\n@bodyMode\n@trackRemoval\nclass ReactTooltip extends React.Component {\n  static get propTypes() {\n    return {\n      uuid: PropTypes.string,\n      children: PropTypes.any,\n      place: PropTypes.string,\n      type: PropTypes.string,\n      effect: PropTypes.string,\n      offset: PropTypes.object,\n      multiline: PropTypes.bool,\n      border: PropTypes.bool,\n      textColor: PropTypes.string,\n      backgroundColor: PropTypes.string,\n      borderColor: PropTypes.string,\n      arrowColor: PropTypes.string,\n      insecure: PropTypes.bool,\n      class: PropTypes.string,\n      className: PropTypes.string,\n      id: PropTypes.string,\n      html: PropTypes.bool,\n      delayHide: PropTypes.number,\n      delayUpdate: PropTypes.number,\n      delayShow: PropTypes.number,\n      event: PropTypes.string,\n      eventOff: PropTypes.string,\n      isCapture: PropTypes.bool,\n      globalEventOff: PropTypes.string,\n      getContent: PropTypes.any,\n      afterShow: PropTypes.func,\n      afterHide: PropTypes.func,\n      overridePosition: PropTypes.func,\n      disable: PropTypes.bool,\n      scrollHide: PropTypes.bool,\n      resizeHide: PropTypes.bool,\n      wrapper: PropTypes.string,\n      bodyMode: PropTypes.bool,\n      possibleCustomEvents: PropTypes.string,\n      possibleCustomEventsOff: PropTypes.string,\n      clickable: PropTypes.bool\n    };\n  }\n\n  static defaultProps = {\n    insecure: true,\n    resizeHide: true,\n    wrapper: 'div',\n    clickable: false\n  };\n\n  static supportedWrappers = ['div', 'span'];\n\n  static displayName = 'ReactTooltip';\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      uuid: props.uuid || generateUUID(),\n      place: props.place || 'top', // Direction of tooltip\n      desiredPlace: props.place || 'top',\n      type: 'dark', // Color theme of tooltip\n      effect: 'float', // float or fixed\n      show: false,\n      border: false,\n      customColors: {},\n      offset: {},\n      extraClass: '',\n      html: false,\n      delayHide: 0,\n      delayShow: 0,\n      event: props.event || null,\n      eventOff: props.eventOff || null,\n      currentEvent: null, // Current mouse event\n      currentTarget: null, // Current target of mouse event\n      ariaProps: parseAria(props), // aria- and role attributes\n      isEmptyTip: false,\n      disable: false,\n      possibleCustomEvents: props.possibleCustomEvents || '',\n      possibleCustomEventsOff: props.possibleCustomEventsOff || '',\n      originTooltip: null,\n      isMultiline: false\n    };\n\n    this.bind([\n      'showTooltip',\n      'updateTooltip',\n      'hideTooltip',\n      'hideTooltipOnScroll',\n      'getTooltipContent',\n      'globalRebuild',\n      'globalShow',\n      'globalHide',\n      'onWindowResize',\n      'mouseOnToolTip'\n    ]);\n\n    this.mount = true;\n    this.delayShowLoop = null;\n    this.delayHideLoop = null;\n    this.delayReshow = null;\n    this.intervalUpdateContent = null;\n  }\n\n  /**\n   * For unify the bind and unbind listener\n   */\n  bind(methodArray) {\n    methodArray.forEach(method => {\n      this[method] = this[method].bind(this);\n    });\n  }\n\n  componentDidMount() {\n    const { insecure, resizeHide } = this.props;\n\n    this.bindListener(); // Bind listener for tooltip\n    this.bindWindowEvents(resizeHide); // Bind global event for static method\n    this.injectStyles(); // Inject styles for each DOM root having tooltip.\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    const { ariaProps } = prevState;\n    const newAriaProps = parseAria(nextProps);\n    const isChanged = Object.keys(newAriaProps).some(props => {\n      return newAriaProps[props] !== ariaProps[props];\n    });\n    if (!isChanged) {\n      return null;\n    }\n    return {\n      ...prevState,\n      ariaProps: newAriaProps\n    };\n  }\n\n  componentWillUnmount() {\n    this.mount = false;\n\n    this.clearTimer();\n\n    this.unbindListener();\n    this.removeScrollListener(this.state.currentTarget);\n    this.unbindWindowEvents();\n  }\n\n  /* Look for the closest DOM root having tooltip and inject styles. */\n  injectStyles() {\n    const { tooltipRef } = this;\n    if (!tooltipRef) {\n      return;\n    }\n\n    let parentNode = tooltipRef.parentNode;\n    while (parentNode.parentNode) {\n      parentNode = parentNode.parentNode;\n    }\n\n    let domRoot;\n\n    switch (parentNode.constructor.name) {\n      case 'Document':\n      case 'HTMLDocument':\n        domRoot = parentNode.head;\n        break;\n      case 'ShadowRoot':\n      default:\n        domRoot = parentNode;\n        break;\n    }\n\n    // Prevent styles duplication.\n    if (!domRoot.querySelector('style[data-react-tooltip]')) {\n      const style = document.createElement('style');\n      style.textContent = baseCss;\n      style.setAttribute('data-react-tooltip', 'true');\n\n      domRoot.appendChild(style);\n    }\n  }\n\n  /**\n   * Return if the mouse is on the tooltip.\n   * @returns {boolean} true - mouse is on the tooltip\n   */\n  mouseOnToolTip() {\n    const { show } = this.state;\n\n    if (show && this.tooltipRef) {\n      /* old IE or Firefox work around */\n      if (!this.tooltipRef.matches) {\n        /* old IE work around */\n        if (this.tooltipRef.msMatchesSelector) {\n          this.tooltipRef.matches = this.tooltipRef.msMatchesSelector;\n        } else {\n          /* old Firefox work around */\n          this.tooltipRef.matches = this.tooltipRef.mozMatchesSelector;\n        }\n      }\n      return this.tooltipRef.matches(':hover');\n    }\n    return false;\n  }\n\n  /**\n   * Pick out corresponded target elements\n   */\n  getTargetArray(id) {\n    let targetArray = [];\n    let selector;\n    if (!id) {\n      selector = '[data-tip]:not([data-for])';\n    } else {\n      const escaped = id.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n      selector = `[data-tip][data-for=\"${escaped}\"]`;\n    }\n\n    // Scan document for shadow DOM elements\n    nodeListToArray(document.getElementsByTagName('*'))\n      .filter(element => element.shadowRoot)\n      .forEach(element => {\n        targetArray = targetArray.concat(\n          nodeListToArray(element.shadowRoot.querySelectorAll(selector))\n        );\n      });\n    return targetArray.concat(\n      nodeListToArray(document.querySelectorAll(selector))\n    );\n  }\n\n  /**\n   * Bind listener to the target elements\n   * These listeners used to trigger showing or hiding the tooltip\n   */\n  bindListener() {\n    const { id, globalEventOff, isCapture } = this.props;\n    const targetArray = this.getTargetArray(id);\n\n    targetArray.forEach(target => {\n      if (target.getAttribute('currentItem') === null) {\n        target.setAttribute('currentItem', 'false');\n      }\n      this.unbindBasicListener(target);\n      if (this.isCustomEvent(target)) {\n        this.customUnbindListener(target);\n      }\n    });\n\n    if (this.isBodyMode()) {\n      this.bindBodyListener(targetArray);\n    } else {\n      targetArray.forEach(target => {\n        const isCaptureMode = this.isCapture(target);\n        const effect = this.getEffect(target);\n        if (this.isCustomEvent(target)) {\n          this.customBindListener(target);\n          return;\n        }\n\n        target.addEventListener('mouseenter', this.showTooltip, isCaptureMode);\n        if (effect === 'float') {\n          target.addEventListener(\n            'mousemove',\n            this.updateTooltip,\n            isCaptureMode\n          );\n        }\n        target.addEventListener('mouseleave', this.hideTooltip, isCaptureMode);\n      });\n    }\n\n    // Global event to hide tooltip\n    if (globalEventOff) {\n      window.removeEventListener(globalEventOff, this.hideTooltip);\n      window.addEventListener(globalEventOff, this.hideTooltip, isCapture);\n    }\n\n    // Track removal of targetArray elements from DOM\n    this.bindRemovalTracker();\n  }\n\n  /**\n   * Unbind listeners on target elements\n   */\n  unbindListener() {\n    const { id, globalEventOff } = this.props;\n    if (this.isBodyMode()) {\n      this.unbindBodyListener();\n    } else {\n      const targetArray = this.getTargetArray(id);\n      targetArray.forEach(target => {\n        this.unbindBasicListener(target);\n        if (this.isCustomEvent(target)) this.customUnbindListener(target);\n      });\n    }\n\n    if (globalEventOff)\n      window.removeEventListener(globalEventOff, this.hideTooltip);\n    this.unbindRemovalTracker();\n  }\n\n  /**\n   * Invoke this before bind listener and unmount the component\n   * it is necessary to invoke this even when binding custom event\n   * so that the tooltip can switch between custom and default listener\n   */\n  unbindBasicListener(target) {\n    const isCaptureMode = this.isCapture(target);\n    target.removeEventListener('mouseenter', this.showTooltip, isCaptureMode);\n    target.removeEventListener('mousemove', this.updateTooltip, isCaptureMode);\n    target.removeEventListener('mouseleave', this.hideTooltip, isCaptureMode);\n  }\n\n  getTooltipContent() {\n    const { getContent, children } = this.props;\n\n    // Generate tooltip content\n    let content;\n    if (getContent) {\n      if (Array.isArray(getContent)) {\n        content = getContent[0] && getContent[0](this.state.originTooltip);\n      } else {\n        content = getContent(this.state.originTooltip);\n      }\n    }\n\n    return getTipContent(\n      this.state.originTooltip,\n      children,\n      content,\n      this.state.isMultiline\n    );\n  }\n\n  isEmptyTip(placeholder) {\n    return (\n      (typeof placeholder === 'string' && placeholder === '') ||\n      placeholder === null\n    );\n  }\n\n  /**\n   * When mouse enter, show the tooltip\n   */\n  showTooltip(e, isGlobalCall) {\n    if (!this.tooltipRef) {\n      return;\n    }\n\n    if (isGlobalCall) {\n      // Don't trigger other elements belongs to other ReactTooltip\n      const targetArray = this.getTargetArray(this.props.id);\n      const isMyElement = targetArray.some(ele => ele === e.currentTarget);\n      if (!isMyElement) return;\n    }\n    // Get the tooltip content\n    // calculate in this phrase so that tip width height can be detected\n    const { multiline, getContent } = this.props;\n    const originTooltip = e.currentTarget.getAttribute('data-tip');\n    const isMultiline =\n      e.currentTarget.getAttribute('data-multiline') || multiline || false;\n\n    // If it is focus event or called by ReactTooltip.show, switch to `solid` effect\n    const switchToSolid = e instanceof window.FocusEvent || isGlobalCall;\n\n    // if it needs to skip adding hide listener to scroll\n    let scrollHide = true;\n    if (e.currentTarget.getAttribute('data-scroll-hide')) {\n      scrollHide = e.currentTarget.getAttribute('data-scroll-hide') === 'true';\n    } else if (this.props.scrollHide != null) {\n      scrollHide = this.props.scrollHide;\n    }\n\n    // Make sure the correct place is set\n    const desiredPlace =\n      e.currentTarget.getAttribute('data-place') || this.props.place || 'top';\n    const effect =\n      (switchToSolid && 'solid') || this.getEffect(e.currentTarget);\n    const offset =\n      e.currentTarget.getAttribute('data-offset') || this.props.offset || {};\n    const result = getPosition(\n      e,\n      e.currentTarget,\n      this.tooltipRef,\n      desiredPlace,\n      desiredPlace,\n      effect,\n      offset\n    );\n    if (result.position && this.props.overridePosition) {\n      result.position = this.props.overridePosition(\n        result.position,\n        e,\n        e.currentTarget,\n        this.tooltipRef,\n        desiredPlace,\n        desiredPlace,\n        effect,\n        offset\n      );\n    }\n\n    const place = result.isNewState ? result.newState.place : desiredPlace;\n\n    // To prevent previously created timers from triggering\n    this.clearTimer();\n\n    const target = e.currentTarget;\n\n    const reshowDelay = this.state.show\n      ? target.getAttribute('data-delay-update') || this.props.delayUpdate\n      : 0;\n\n    const self = this;\n\n    const updateState = function updateState() {\n      self.setState(\n        {\n          originTooltip: originTooltip,\n          isMultiline: isMultiline,\n          desiredPlace: desiredPlace,\n          place: place,\n          type: target.getAttribute('data-type') || self.props.type || 'dark',\n          customColors: {\n            text:\n              target.getAttribute('data-text-color') ||\n              self.props.textColor ||\n              null,\n            background:\n              target.getAttribute('data-background-color') ||\n              self.props.backgroundColor ||\n              null,\n            border:\n              target.getAttribute('data-border-color') ||\n              self.props.borderColor ||\n              null,\n            arrow:\n              target.getAttribute('data-arrow-color') ||\n              self.props.arrowColor ||\n              null\n          },\n          effect: effect,\n          offset: offset,\n          html:\n            (target.getAttribute('data-html')\n              ? target.getAttribute('data-html') === 'true'\n              : self.props.html) || false,\n          delayShow:\n            target.getAttribute('data-delay-show') || self.props.delayShow || 0,\n          delayHide:\n            target.getAttribute('data-delay-hide') || self.props.delayHide || 0,\n          delayUpdate:\n            target.getAttribute('data-delay-update') ||\n            self.props.delayUpdate ||\n            0,\n          border:\n            (target.getAttribute('data-border')\n              ? target.getAttribute('data-border') === 'true'\n              : self.props.border) || false,\n          extraClass:\n            target.getAttribute('data-class') ||\n            self.props.class ||\n            self.props.className ||\n            '',\n          disable:\n            (target.getAttribute('data-tip-disable')\n              ? target.getAttribute('data-tip-disable') === 'true'\n              : self.props.disable) || false,\n          currentTarget: target\n        },\n        () => {\n          if (scrollHide) {\n            self.addScrollListener(self.state.currentTarget);\n          }\n\n          self.updateTooltip(e);\n\n          if (getContent && Array.isArray(getContent)) {\n            self.intervalUpdateContent = setInterval(() => {\n              if (self.mount) {\n                const { getContent } = self.props;\n                const placeholder = getTipContent(\n                  originTooltip,\n                  '',\n                  getContent[0](),\n                  isMultiline\n                );\n                const isEmptyTip = self.isEmptyTip(placeholder);\n                self.setState({ isEmptyTip });\n                self.updatePosition();\n              }\n            }, getContent[1]);\n          }\n        }\n      );\n    };\n\n    // If there is no delay call immediately, don't allow events to get in first.\n    if (reshowDelay) {\n      this.delayReshow = setTimeout(updateState, reshowDelay);\n    } else {\n      updateState();\n    }\n  }\n\n  /**\n   * When mouse hover, update tool tip\n   */\n  updateTooltip(e) {\n    const { delayShow, disable } = this.state;\n    const { afterShow } = this.props;\n    const placeholder = this.getTooltipContent();\n    const eventTarget = e.currentTarget || e.target;\n\n    // Check if the mouse is actually over the tooltip, if so don't hide the tooltip\n    if (this.mouseOnToolTip()) {\n      return;\n    }\n\n    // if the tooltip is empty, disable the tooltip\n    if (this.isEmptyTip(placeholder) || disable) {\n      return;\n    }\n\n    const delayTime = !this.state.show ? parseInt(delayShow, 10) : 0;\n\n    const updateState = () => {\n      if (\n        (Array.isArray(placeholder) && placeholder.length > 0) ||\n        placeholder\n      ) {\n        const isInvisible = !this.state.show;\n        this.setState(\n          {\n            currentEvent: e,\n            currentTarget: eventTarget,\n            show: true\n          },\n          () => {\n            this.updatePosition();\n            if (isInvisible && afterShow) {\n              afterShow(e);\n            }\n          }\n        );\n      }\n    };\n\n    clearTimeout(this.delayShowLoop);\n    if (delayTime) {\n      this.delayShowLoop = setTimeout(updateState, delayTime);\n    } else {\n      updateState();\n    }\n  }\n\n  /*\n   * If we're mousing over the tooltip remove it when we leave.\n   */\n  listenForTooltipExit() {\n    const { show } = this.state;\n\n    if (show && this.tooltipRef) {\n      this.tooltipRef.addEventListener('mouseleave', this.hideTooltip);\n    }\n  }\n\n  removeListenerForTooltipExit() {\n    const { show } = this.state;\n\n    if (show && this.tooltipRef) {\n      this.tooltipRef.removeEventListener('mouseleave', this.hideTooltip);\n    }\n  }\n\n  /**\n   * When mouse leave, hide tooltip\n   */\n  hideTooltip(e, hasTarget, options = { isScroll: false }) {\n    const { disable } = this.state;\n    const { isScroll } = options;\n    const delayHide = isScroll ? 0 : this.state.delayHide;\n    const { afterHide } = this.props;\n    const placeholder = this.getTooltipContent();\n    if (!this.mount) return;\n    if (this.isEmptyTip(placeholder) || disable) return; // if the tooltip is empty, disable the tooltip\n    if (hasTarget) {\n      // Don't trigger other elements belongs to other ReactTooltip\n      const targetArray = this.getTargetArray(this.props.id);\n      const isMyElement = targetArray.some(ele => ele === e.currentTarget);\n      if (!isMyElement || !this.state.show) return;\n    }\n\n    const resetState = () => {\n      const isVisible = this.state.show;\n      // Check if the mouse is actually over the tooltip, if so don't hide the tooltip\n      if (this.mouseOnToolTip()) {\n        this.listenForTooltipExit();\n        return;\n      }\n\n      this.removeListenerForTooltipExit();\n\n      this.setState({ show: false }, () => {\n        this.removeScrollListener(this.state.currentTarget);\n        if (isVisible && afterHide) {\n          afterHide(e);\n        }\n      });\n    };\n\n    this.clearTimer();\n    if (delayHide) {\n      this.delayHideLoop = setTimeout(resetState, parseInt(delayHide, 10));\n    } else {\n      resetState();\n    }\n  }\n\n  /**\n   * When scroll, hide tooltip\n   */\n  hideTooltipOnScroll(event, hasTarget) {\n    this.hideTooltip(event, hasTarget, { isScroll: true });\n  }\n\n  /**\n   * Add scroll event listener when tooltip show\n   * automatically hide the tooltip when scrolling\n   */\n  addScrollListener(currentTarget) {\n    const isCaptureMode = this.isCapture(currentTarget);\n    window.addEventListener('scroll', this.hideTooltipOnScroll, isCaptureMode);\n  }\n\n  removeScrollListener(currentTarget) {\n    const isCaptureMode = this.isCapture(currentTarget);\n    window.removeEventListener(\n      'scroll',\n      this.hideTooltipOnScroll,\n      isCaptureMode\n    );\n  }\n\n  // Calculation the position\n  updatePosition() {\n    const {\n      currentEvent,\n      currentTarget,\n      place,\n      desiredPlace,\n      effect,\n      offset\n    } = this.state;\n    const node = this.tooltipRef;\n    const result = getPosition(\n      currentEvent,\n      currentTarget,\n      node,\n      place,\n      desiredPlace,\n      effect,\n      offset\n    );\n    if (result.position && this.props.overridePosition) {\n      result.position = this.props.overridePosition(\n        result.position,\n        currentEvent,\n        currentTarget,\n        node,\n        place,\n        desiredPlace,\n        effect,\n        offset\n      );\n    }\n\n    if (result.isNewState) {\n      // Switch to reverse placement\n      return this.setState(result.newState, () => {\n        this.updatePosition();\n      });\n    }\n\n    // Set tooltip position\n    node.style.left = result.position.left + 'px';\n    node.style.top = result.position.top + 'px';\n  }\n\n  /**\n   * CLear all kinds of timeout of interval\n   */\n  clearTimer() {\n    clearTimeout(this.delayShowLoop);\n    clearTimeout(this.delayHideLoop);\n    clearTimeout(this.delayReshow);\n    clearInterval(this.intervalUpdateContent);\n  }\n\n  hasCustomColors() {\n    return Boolean(\n      Object.keys(this.state.customColors).find(\n        color => color !== 'border' && this.state.customColors[color]\n      ) ||\n        (this.state.border && this.state.customColors['border'])\n    );\n  }\n\n  render() {\n    const { extraClass, html, ariaProps, disable } = this.state;\n    const content = this.getTooltipContent();\n    const isEmptyTip = this.isEmptyTip(content);\n    const style = generateTooltipStyle(\n      this.state.uuid,\n      this.state.customColors,\n      this.state.type,\n      this.state.border\n    );\n\n    const tooltipClass =\n      '__react_component_tooltip' +\n      ` ${this.state.uuid}` +\n      (this.state.show && !disable && !isEmptyTip ? ' show' : '') +\n      (this.state.border ? ' border' : '') +\n      ` place-${this.state.place}` + // top, bottom, left, right\n      ` type-${this.hasCustomColors() ? 'custom' : this.state.type}` + // dark, success, warning, error, info, light, custom\n      (this.props.delayUpdate ? ' allow_hover' : '') +\n      (this.props.clickable ? ' allow_click' : '');\n\n    let Wrapper = this.props.wrapper;\n\n    if (ReactTooltip.supportedWrappers.indexOf(Wrapper) < 0) {\n      Wrapper = ReactTooltip.defaultProps.wrapper;\n    }\n\n    const wrapperClassName = [tooltipClass, extraClass]\n      .filter(Boolean)\n      .join(' ');\n\n    if (html) {\n      const htmlContent = `${content}\\n<style>${style}</style>`;\n\n      return (\n        <Wrapper\n          className={`${wrapperClassName}`}\n          id={this.props.id}\n          ref={ref => (this.tooltipRef = ref)}\n          {...ariaProps}\n          data-id=\"tooltip\"\n          dangerouslySetInnerHTML={{ __html: htmlContent }}\n        />\n      );\n    } else {\n      return (\n        <Wrapper\n          className={`${wrapperClassName}`}\n          id={this.props.id}\n          {...ariaProps}\n          ref={ref => (this.tooltipRef = ref)}\n          data-id=\"tooltip\"\n        >\n          <style dangerouslySetInnerHTML={{ __html: style }} />\n          {content}\n        </Wrapper>\n      );\n    }\n  }\n}\n\nexport default ReactTooltip;\n","/**\n * Events that should be bound to the window\n */\nimport CONSTANT from '../constant';\n\nexport default function(target) {\n  target.prototype.bindWindowEvents = function(resizeHide) {\n    // ReactTooltip.hide\n    window.removeEventListener(CONSTANT.GLOBAL.HIDE, this.globalHide);\n    window.addEventListener(CONSTANT.GLOBAL.HIDE, this.globalHide, false);\n\n    // ReactTooltip.rebuild\n    window.removeEventListener(CONSTANT.GLOBAL.REBUILD, this.globalRebuild);\n    window.addEventListener(CONSTANT.GLOBAL.REBUILD, this.globalRebuild, false);\n\n    // ReactTooltip.show\n    window.removeEventListener(CONSTANT.GLOBAL.SHOW, this.globalShow);\n    window.addEventListener(CONSTANT.GLOBAL.SHOW, this.globalShow, false);\n\n    // Resize\n    if (resizeHide) {\n      window.removeEventListener('resize', this.onWindowResize);\n      window.addEventListener('resize', this.onWindowResize, false);\n    }\n  };\n\n  target.prototype.unbindWindowEvents = function() {\n    window.removeEventListener(CONSTANT.GLOBAL.HIDE, this.globalHide);\n    window.removeEventListener(CONSTANT.GLOBAL.REBUILD, this.globalRebuild);\n    window.removeEventListener(CONSTANT.GLOBAL.SHOW, this.globalShow);\n    window.removeEventListener('resize', this.onWindowResize);\n  };\n\n  /**\n   * invoked by resize event of window\n   */\n  target.prototype.onWindowResize = function() {\n    if (!this.mount) return;\n    this.hideTooltip();\n  };\n}\n","/**\n * Util method to judge if it should follow capture model\n */\n\nexport default function(target) {\n  target.prototype.isCapture = function(currentTarget) {\n    return (\n      (currentTarget &&\n        currentTarget.getAttribute('data-iscapture') === 'true') ||\n      this.props.isCapture ||\n      false\n    );\n  };\n}\n","/**\n * Util method to get effect\n */\n\nexport default function(target) {\n  target.prototype.getEffect = function(currentTarget) {\n    const dataEffect = currentTarget.getAttribute('data-effect');\n    return dataEffect || this.props.effect || 'float';\n  };\n}\n","import { v4 as uuid } from 'uuid';\n\nexport function generateUUID() {\n  return 't' + uuid();\n}\n","var baseSum = require('./_baseSum'),\n    identity = require('./identity');\n\n/**\n * Computes the sum of the values in `array`.\n *\n * @static\n * @memberOf _\n * @since 3.4.0\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {number} Returns the sum.\n * @example\n *\n * _.sum([4, 2, 8, 6]);\n * // => 20\n */\nfunction sum(array) {\n  return (array && array.length)\n    ? baseSum(array, identity)\n    : 0;\n}\n\nmodule.exports = sum;\n","export type AlignmentOptionType = 'start' | 'center' | 'end' | number\n\nexport type AlignmentType = {\n  measure: (n: number) => number\n}\n\nexport function Alignment(\n  align: AlignmentOptionType,\n  viewSize: number,\n): AlignmentType {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function percent(): number {\n    return viewSize * Number(align)\n  }\n\n  function measure(n: number): number {\n    if (typeof align === 'number') return percent()\n    return predefined[align](n)\n  }\n\n  const self: AlignmentType = {\n    measure,\n  }\n  return self\n}\n","export function map(\n  value: number,\n  iStart: number,\n  iStop: number,\n  oStart: number,\n  oStop: number,\n): number {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart))\n}\n\nexport function mathSign(n: number): number {\n  return !n ? 0 : n / Math.abs(n)\n}\n\nexport function deltaAbs(valueB: number, valueA: number): number {\n  return Math.abs(valueB - valueA)\n}\n\nexport function factorAbs(valueB: number, valueA: number): number {\n  if (valueB === 0 || valueA === 0) return 0\n  if (Math.abs(valueB) <= Math.abs(valueA)) return 0\n  const diff = deltaAbs(Math.abs(valueB), Math.abs(valueA))\n  return Math.abs(diff / valueB)\n}\n\nexport function roundToDecimals(decimalPoints: number): (n: number) => number {\n  const pow = Math.pow(10, decimalPoints)\n  return (n: number): number => Math.round(n * pow) / pow\n}\n\nexport function debounce(callback: () => void, time: number): () => void {\n  let timeout = 0\n  return (): void => {\n    window.clearTimeout(timeout)\n    timeout = window.setTimeout(callback, time) || 0\n  }\n}\n\nexport function groupArray<GenericType>(\n  array: GenericType[],\n  size: number,\n): GenericType[][] {\n  const groups = []\n  for (let i = 0; i < array.length; i += size) {\n    groups.push(array.slice(i, i + size))\n  }\n  return groups\n}\n\nexport function arrayKeys<GenericType>(array: GenericType[]): number[] {\n  return Object.keys(array).map(Number)\n}\n\nexport function arrayLast<GenericType>(array: GenericType[]): GenericType {\n  return array[lastIndex(array)]\n}\n\nexport function lastIndex<GenericType>(array: GenericType[]): number {\n  return Math.max(0, array.length - 1)\n}\n\nexport function removeClass(node: HTMLElement, className: string): void {\n  const cl = node.classList\n  if (className && cl.contains(className)) cl.remove(className)\n}\n\nexport function addClass(node: HTMLElement, className: string): void {\n  const cl = node.classList\n  if (className && !cl.contains(className)) cl.add(className)\n}\n","import { LimitType } from './limit'\nimport { mathSign } from './utils'\n\nexport type CounterType = {\n  min: number\n  max: number\n  get: () => number\n  set: (n: number) => CounterType\n  add: (n: number) => CounterType\n  clone: () => CounterType\n}\n\nexport function Counter(\n  limit: LimitType,\n  loop: boolean,\n  start: number,\n): CounterType {\n  const { min, max } = limit\n  const type = loop ? 'loop' : 'constrain'\n  const withinLimit = limit[type]\n  let counter = withinLimit(start)\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): CounterType {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): CounterType {\n    if (n !== 0) {\n      const sign = mathSign(n)\n      set(get() + sign)\n      return add(n + sign * -1)\n    }\n    return self\n  }\n\n  function clone(): CounterType {\n    return Counter(limit, loop, get())\n  }\n\n  const self: CounterType = {\n    add,\n    clone,\n    get,\n    max,\n    min,\n    set,\n  }\n  return self\n}\n","type EventRemoverType = () => void\ntype EventHandlerType = EventListener | EventListenerObject | null\ntype EventOptionsType = boolean | AddEventListenerOptions | undefined\n\nexport type EventStoreType = {\n  add: (\n    node: EventTarget,\n    type: keyof WindowEventMap,\n    handler: EventHandlerType,\n    options?: EventOptionsType,\n  ) => EventStoreType\n  removeAll: () => EventStoreType\n}\n\nexport function EventStore(): EventStoreType {\n  let listeners: EventRemoverType[] = []\n\n  function add(\n    node: EventTarget,\n    type: string,\n    handler: EventHandlerType,\n    options: EventOptionsType = false,\n  ): EventStoreType {\n    node.addEventListener(type, handler, options)\n    listeners.push(() => {\n      return node.removeEventListener(type, handler, options)\n    })\n    return self\n  }\n\n  function removeAll(): EventStoreType {\n    listeners = listeners.filter((remove) => remove())\n    return self\n  }\n\n  const self: EventStoreType = {\n    add,\n    removeAll,\n  }\n  return self\n}\n","export type Vector1DType = {\n  get: () => number\n  set: (v: Vector1DType | number) => Vector1DType\n  add: (v: Vector1DType | number) => Vector1DType\n  subtract: (v: Vector1DType | number) => Vector1DType\n  multiply: (n: number) => Vector1DType\n  divide: (n: number) => Vector1DType\n  normalize: () => Vector1DType\n}\n\nexport function Vector1D(value: number): Vector1DType {\n  let vector = value\n\n  function get(): number {\n    return vector\n  }\n\n  function set(n: Vector1DType | number): Vector1DType {\n    vector = readNumber(n)\n    return self\n  }\n\n  function add(n: Vector1DType | number): Vector1DType {\n    vector += readNumber(n)\n    return self\n  }\n\n  function subtract(n: Vector1DType | number): Vector1DType {\n    vector -= readNumber(n)\n    return self\n  }\n\n  function multiply(n: number): Vector1DType {\n    vector *= n\n    return self\n  }\n\n  function divide(n: number): Vector1DType {\n    vector /= n\n    return self\n  }\n\n  function normalize(): Vector1DType {\n    if (vector !== 0) divide(vector)\n    return self\n  }\n\n  function readNumber(n: Vector1DType | number): number {\n    return typeof n === 'number' ? n : n.get()\n  }\n\n  const self: Vector1DType = {\n    add,\n    divide,\n    get,\n    multiply,\n    normalize,\n    set,\n    subtract,\n  }\n  return self\n}\n","import { AnimationType } from './animation'\nimport { CounterType } from './counter'\nimport { DirectionType } from './direction'\nimport { DragTrackerType } from './dragTracker'\nimport { EventEmitterType } from './eventEmitter'\nimport { AxisType } from './axis'\nimport { EventStore } from './eventStore'\nimport { LimitType } from './limit'\nimport { ScrollBodyType } from './scrollBody'\nimport { ScrollTargetType } from './scrollTarget'\nimport { ScrollToType } from './scrollTo'\nimport { Vector1D, Vector1DType } from './vector1d'\nimport { deltaAbs, factorAbs, mathSign } from './utils'\n\nexport type DragHandlerType = {\n  addActivationEvents: () => void\n  clickAllowed: () => boolean\n  pointerDown: () => boolean\n  removeAllEvents: () => void\n}\n\nexport function DragHandler(\n  axis: AxisType,\n  direction: DirectionType,\n  rootNode: HTMLElement,\n  target: Vector1DType,\n  dragFree: boolean,\n  dragTracker: DragTrackerType,\n  location: Vector1DType,\n  animation: AnimationType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  index: CounterType,\n  limit: LimitType,\n  events: EventEmitterType,\n): DragHandlerType {\n  const { scroll: scrollAxis, cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const startScroll = Vector1D(0)\n  const startCross = Vector1D(0)\n  const dragStartPoint = Vector1D(0)\n  const activationEvents = EventStore()\n  const interactionEvents = EventStore()\n  const snapForceBoost = { mouse: 2.5, touch: 3.5 }\n  const freeForceBoost = { mouse: 5, touch: 7 }\n  const baseSpeed = dragFree ? 5 : 12\n  const dragThreshold = 4\n\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function addActivationEvents(): void {\n    const node = rootNode\n    activationEvents\n      .add(node, 'touchmove', () => undefined)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click)\n  }\n\n  function addInteractionEvents(): void {\n    const node = !isMouse ? rootNode : document\n    interactionEvents\n      .add(node, 'touchmove', move)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move)\n      .add(node, 'mouseup', up)\n  }\n\n  function removeAllEvents(): void {\n    activationEvents.removeAll()\n    interactionEvents.removeAll()\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const name = node.nodeName || ''\n    return focusNodes.indexOf(name) > -1\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function allowedForce(force: number): number {\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const seekNext = !targetChanged && Math.abs(force) > dragThreshold\n    const destination = force + location.get()\n\n    if (seekNext && !dragFree && !limit.reachedAny(destination)) {\n      const next = index.clone().add(mathSign(force) * -1)\n      return scrollTarget.byIndex(next.get(), 0).distance\n    }\n    return scrollTarget.byDistance(force, !dragFree).distance\n  }\n\n  function down(evt: Event): void {\n    isMouse = evt.type === 'mousedown'\n    if (isMouse && (evt as MouseEvent).button !== 0) return\n\n    const isMoving = deltaAbs(target.get(), location.get()) >= 2\n    const clearPreventClick = isMouse || !isMoving\n    const isNotFocusNode = !isFocusNode(evt.target as Element)\n    const preventDefault = isMoving || (isMouse && isNotFocusNode)\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    dragStartPoint.set(target)\n    target.set(location)\n    scrollBody.useBaseMass().useSpeed(80)\n    addInteractionEvents()\n    startScroll.set(dragTracker.readPoint(evt, scrollAxis))\n    startCross.set(dragTracker.readPoint(evt, crossAxis))\n    events.emit('pointerDown')\n\n    if (clearPreventClick) preventClick = false\n    if (preventDefault) evt.preventDefault()\n  }\n\n  function move(evt: Event): void {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up()\n      const moveScroll = dragTracker.readPoint(evt, scrollAxis).get()\n      const moveCross = dragTracker.readPoint(evt, crossAxis).get()\n      const diffScroll = deltaAbs(moveScroll, startScroll.get())\n      const diffCross = deltaAbs(moveCross, startCross.get())\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll && !preventClick) return up()\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (!preventClick && diff) preventClick = true\n    animation.start()\n    target.add(direction.applyTo(diff))\n    evt.preventDefault()\n  }\n\n  function up(): void {\n    const rawForce = dragTracker.pointerUp() * forceBoost()\n    const force = allowedForce(direction.applyTo(rawForce))\n    const speedFactor = factorAbs(rawForce, force)\n    const isMoving = deltaAbs(target.get(), dragStartPoint.get()) >= 0.5\n\n    if (isMoving && !isMouse) preventClick = true\n    preventScroll = false\n    pointerIsDown = false\n    interactionEvents.removeAll()\n    scrollBody.useSpeed(baseSpeed + baseSpeed * speedFactor)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    events.emit('pointerUp')\n  }\n\n  function click(evt: Event): void {\n    if (preventClick) evt.preventDefault()\n  }\n\n  function clickAllowed(): boolean {\n    return !preventClick\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandlerType = {\n    addActivationEvents,\n    clickAllowed,\n    pointerDown,\n    removeAllEvents,\n  }\n  return self\n}\n","export type LimitType = {\n  min: number\n  max: number\n  length: number\n  loop: (n: number) => number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(min: number, max: number): LimitType {\n  const length = Math.abs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function removeOffset(n: number): number {\n    if (min === max) return n\n    while (reachedMin(n)) n += length\n    while (reachedMax(n)) n -= length\n    return n\n  }\n\n  function loop(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? max : min\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  const self: LimitType = {\n    constrain,\n    length,\n    loop,\n    max,\n    min,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n  return self\n}\n","import { map, roundToDecimals, mathSign } from './utils'\nimport { Vector1D, Vector1DType } from './vector1d'\n\nexport type ScrollBodyType = {\n  direction: () => number\n  seek: (v: Vector1DType) => ScrollBodyType\n  settle: (v: Vector1DType) => boolean\n  update: () => void\n  useBaseMass: () => ScrollBodyType\n  useBaseSpeed: () => ScrollBodyType\n  useMass: (n: number) => ScrollBodyType\n  useSpeed: (n: number) => ScrollBodyType\n}\n\nexport function ScrollBody(\n  location: Vector1DType,\n  baseSpeed: number,\n  baseMass: number,\n): ScrollBodyType {\n  const roundToTwoDecimals = roundToDecimals(2)\n  const velocity = Vector1D(0)\n  const acceleration = Vector1D(0)\n  const attraction = Vector1D(0)\n\n  let attractionDirection = 0\n  let speed = baseSpeed\n  let mass = baseMass\n\n  function update(): void {\n    velocity.add(acceleration)\n    location.add(velocity)\n    acceleration.multiply(0)\n  }\n\n  function applyForce(v: Vector1DType): void {\n    v.divide(mass)\n    acceleration.add(v)\n  }\n\n  function seek(v: Vector1DType): ScrollBodyType {\n    attraction.set(v).subtract(location)\n    const magnitude = map(attraction.get(), 0, 100, 0, speed)\n    attractionDirection = mathSign(attraction.get())\n    attraction.normalize().multiply(magnitude).subtract(velocity)\n    applyForce(attraction)\n    return self\n  }\n\n  function settle(v: Vector1DType): boolean {\n    const diff = v.get() - location.get()\n    const hasSettled = !roundToTwoDecimals(diff)\n    if (hasSettled) location.set(v)\n    return hasSettled\n  }\n\n  function direction(): number {\n    return attractionDirection\n  }\n\n  function useBaseSpeed(): ScrollBodyType {\n    return useSpeed(baseSpeed)\n  }\n\n  function useBaseMass(): ScrollBodyType {\n    return useMass(baseMass)\n  }\n\n  function useSpeed(n: number): ScrollBodyType {\n    speed = n\n    return self\n  }\n\n  function useMass(n: number): ScrollBodyType {\n    mass = n\n    return self\n  }\n\n  const self: ScrollBodyType = {\n    direction,\n    seek,\n    settle,\n    update,\n    useBaseMass,\n    useBaseSpeed,\n    useMass,\n    useSpeed,\n  }\n  return self\n}\n","import { LimitType } from './limit'\nimport { ScrollBodyType } from './scrollBody'\nimport { Vector1DType } from './vector1d'\n\nexport type ScrollBoundsType = {\n  constrain: (v: Vector1DType, pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(\n  limit: LimitType,\n  location: Vector1DType,\n  scrollBody: ScrollBodyType,\n): ScrollBoundsType {\n  const pullBackThreshold = 10\n  let disabled = false\n\n  function shouldConstrain(target: Vector1DType): boolean {\n    if (disabled) return false\n    if (!limit.reachedAny(target.get())) return false\n    if (!limit.reachedAny(location.get())) return false\n    return true\n  }\n\n  function constrain(target: Vector1DType, pointerDown: boolean): void {\n    if (!shouldConstrain(target)) return\n    const friction = pointerDown ? 0.7 : 0.4\n    const diffToTarget = target.get() - location.get()\n\n    target.subtract(diffToTarget * friction)\n\n    if (!pointerDown && Math.abs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()))\n      scrollBody.useSpeed(10).useMass(3)\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBoundsType = {\n    constrain,\n    toggleActive,\n  }\n  return self\n}\n","import { Limit, LimitType } from './limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollContainOptionType = '' | 'trimSnaps' | 'keepSnaps'\n\nexport type ScrollContainType = {\n  snapsContained: number[]\n}\n\nexport function ScrollContain(\n  viewSize: number,\n  contentSize: number,\n  snaps: number[],\n  snapsAligned: number[],\n  containScroll: ScrollContainOptionType,\n): ScrollContainType {\n  const scrollBounds = Limit(-contentSize + viewSize, snaps[0])\n  const snapsBounded = snapsAligned.map(scrollBounds.constrain)\n  const snapsContained = measureContained()\n\n  function findDuplicates(): LimitType {\n    const startSnap = snapsBounded[0]\n    const endSnap = arrayLast(snapsBounded)\n    const min = snapsBounded.lastIndexOf(startSnap)\n    const max = snapsBounded.indexOf(endSnap) + 1\n    return Limit(min, max)\n  }\n\n  function measureContained(): number[] {\n    if (contentSize <= viewSize) return [scrollBounds.max]\n    if (containScroll === 'keepSnaps') return snapsBounded\n    const { min, max } = findDuplicates()\n    return snapsBounded.slice(min, max)\n  }\n\n  const self: ScrollContainType = {\n    snapsContained,\n  }\n  return self\n}\n","import { Limit, LimitType } from './limit'\nimport { PxToPercentType } from './pxToPercent'\nimport { Vector1DType } from './vector1d'\n\nexport type ScrollLooperType = {\n  loop: (vectors: Vector1DType[], direction: number) => void\n}\n\nexport function ScrollLooper(\n  contentSize: number,\n  pxToPercent: PxToPercentType,\n  limit: LimitType,\n  location: Vector1DType,\n): ScrollLooperType {\n  const min = limit.min + pxToPercent.measure(0.1)\n  const max = limit.max + pxToPercent.measure(0.1)\n  const { reachedMin, reachedMax } = Limit(min, max)\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(vectors: Vector1DType[], direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach((v) => v.add(loopDistance))\n  }\n\n  const self: ScrollLooperType = {\n    loop,\n  }\n  return self\n}\n","import { LimitType } from './limit'\n\nexport type ScrollProgressType = {\n  get: (n: number) => number\n}\n\nexport function ScrollProgress(limit: LimitType): ScrollProgressType {\n  const { max, length: scrollLength } = limit\n\n  function get(n: number): number {\n    const currentLocation = n - max\n    return currentLocation / -scrollLength\n  }\n\n  const self: ScrollProgressType = {\n    get,\n  }\n  return self\n}\n","import { AlignmentType } from './alignment'\nimport { AxisType } from './axis'\nimport { PxToPercentType } from './pxToPercent'\nimport { arrayLast, groupArray } from './utils'\n\nexport type ScrollSnapType = {\n  snaps: number[]\n  snapsAligned: number[]\n}\n\nexport function ScrollSnap(\n  axis: AxisType,\n  alignment: AlignmentType,\n  pxToPercent: PxToPercentType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slidesToScroll: number,\n): ScrollSnapType {\n  const { startEdge, endEdge } = axis\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  function measureSizes(): number[] {\n    return groupArray(slideRects, slidesToScroll)\n      .map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge])\n      .map(pxToPercent.measure)\n      .map(Math.abs)\n  }\n\n  function measureUnaligned(): number[] {\n    return slideRects\n      .map((rect) => containerRect[startEdge] - rect[startEdge])\n      .map(pxToPercent.measure)\n      .map((snap) => -Math.abs(snap))\n  }\n\n  function measureAligned(): number[] {\n    const groupedSnaps = groupArray(snaps, slidesToScroll).map((g) => g[0])\n    const alignments = measureSizes().map(alignment.measure)\n    return groupedSnaps.map((snap, index) => snap + alignments[index])\n  }\n\n  const self: ScrollSnapType = {\n    snaps,\n    snapsAligned,\n  }\n  return self\n}\n","import { CounterType } from './counter'\nimport { LimitType } from './limit'\nimport { Vector1DType } from './vector1d'\n\nexport type TargetType = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTargetType = {\n  byIndex: (target: number, direction: number) => TargetType\n  byDistance: (force: number, snap: boolean) => TargetType\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(\n  indexCurrent: CounterType,\n  loop: boolean,\n  scrollSnaps: number[],\n  contentSize: number,\n  limit: LimitType,\n  targetVector: Vector1DType,\n): ScrollTargetType {\n  const { reachedMax, reachedAny, removeOffset } = limit\n\n  function minDistance(d1: number, d2: number): number {\n    return Math.abs(d1) < Math.abs(d2) ? d1 : d2\n  }\n\n  function findTargetSnap(target: number): TargetType {\n    const distance = removeOffset(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map((scrollSnap) => scrollSnap - distance)\n      .map((diffToSnap) => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => Math.abs(d1.diff) - Math.abs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const t1 = target\n    const t2 = target + contentSize\n    const t3 = target - contentSize\n\n    if (!loop) return t1\n    if (!direction) return minDistance(minDistance(t1, t2), t3)\n\n    const shortest = minDistance(t1, direction === 1 ? t2 : t3)\n    return Math.abs(shortest) * direction\n  }\n\n  function findTargetIndex(target: number, index: number): number {\n    const reachedBound = !loop && reachedAny(target)\n    if (!reachedBound) return index\n\n    const { min, max } = indexCurrent\n    return reachedMax(target) ? min : max\n  }\n\n  function byIndex(index: number, direction: number): TargetType {\n    const diffToSnap = scrollSnaps[index] - targetVector.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): TargetType {\n    const target = targetVector.get() + distance\n    const targetSnap = findTargetSnap(target)\n    const index = findTargetIndex(target, targetSnap.index)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnap.distance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTargetType = {\n    byDistance,\n    byIndex,\n    shortcut,\n  }\n  return self\n}\n","import { AxisType } from './axis'\nimport { arrayKeys } from './utils'\nimport { SlidesInViewType } from './slidesInView'\nimport { Vector1DType } from './vector1d'\n\ntype LoopEdgeType = 'start' | 'end'\n\ntype LoopPointType = {\n  point: number\n  location: number\n  index: number\n  getTarget: () => number\n}\n\nexport type SlideLooperType = {\n  canLoop: () => boolean\n  clear: (slides: HTMLElement[]) => void\n  loop: (slides: HTMLElement[]) => void\n  loopPoints: LoopPointType[]\n}\n\nexport function SlideLooper(\n  axis: AxisType,\n  viewSize: number,\n  contentSize: number,\n  slideSizesWithGaps: number[],\n  scrollSnaps: number[],\n  slidesInView: SlidesInViewType,\n  scrollLocation: Vector1DType,\n): SlideLooperType {\n  const ascItems = arrayKeys(slideSizesWithGaps)\n  const descItems = arrayKeys(slideSizesWithGaps).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizesWithGaps[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findLoopPoints(\n    indexes: number[],\n    edge: LoopEdgeType,\n  ): LoopPointType[] {\n    const isStartEdge = edge === 'start'\n    const offset = isStartEdge ? -contentSize : contentSize\n    const slideBounds = slidesInView.findSlideBounds(offset)\n\n    return indexes.map((index) => {\n      const initial = isStartEdge ? 0 : -contentSize\n      const altered = isStartEdge ? contentSize : 0\n      const bounds = slideBounds.filter((b) => b.index === index)[0]\n      const point = bounds[isStartEdge ? 'end' : 'start']\n      const getTarget = (): number =>\n        scrollLocation.get() > point ? initial : altered\n      return { point, getTarget, index, location: -1 }\n    })\n  }\n\n  function startPoints(): LoopPointType[] {\n    const gap = scrollSnaps[0] - 1\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, 'end')\n  }\n\n  function endPoints(): LoopPointType[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, 'start')\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0\n    })\n  }\n\n  function loop(slides: HTMLElement[]): void {\n    loopPoints.forEach((loopPoint) => {\n      const { getTarget, location, index } = loopPoint\n      const target = getTarget()\n      if (target !== location) {\n        slides[index].style[axis.startEdge] = `${target}%`\n        loopPoint.location = target\n      }\n    })\n  }\n\n  function clear(slides: HTMLElement[]): void {\n    loopPoints.forEach(({ index }) => {\n      slides[index].style[axis.startEdge] = ''\n    })\n  }\n\n  const self: SlideLooperType = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints,\n  }\n  return self\n}\n","import { EventStore, EventStoreType } from './eventStore'\nimport { ScrollToType } from './scrollTo'\n\nexport type SlideFocusType = {\n  addActivationEvents: (slides: HTMLElement[]) => void\n  removeAllEvents: EventStoreType['removeAll']\n}\n\nexport function SlideFocus(\n  rootNode: HTMLElement,\n  scrollTo: ScrollToType,\n  slidesToScroll: number,\n): SlideFocusType {\n  const eventStore = EventStore()\n  const removeAllEvents = eventStore.removeAll\n  let lastTabPressTime = 0\n\n  function registerTabPress(event: Event): void {\n    if ((event as KeyboardEvent).keyCode !== 9) return\n    lastTabPressTime = new Date().getTime()\n  }\n\n  function addFocusEvent(slide: HTMLElement, index: number): void {\n    const focus = (): void => {\n      const nowTime = new Date().getTime()\n      const diffTime = nowTime - lastTabPressTime\n      if (diffTime > 10) return\n\n      rootNode.scrollLeft = 0\n      const selectedIndex = Math.floor(index / slidesToScroll)\n      scrollTo.index(selectedIndex, 0)\n    }\n    eventStore.add(slide, 'focus', focus, true)\n  }\n\n  function addActivationEvents(slides: HTMLElement[]): void {\n    eventStore.add(document, 'keydown', registerTabPress, false)\n    slides.forEach(addFocusEvent)\n  }\n\n  const self: SlideFocusType = {\n    addActivationEvents,\n    removeAllEvents,\n  }\n  return self\n}\n","import { AxisType } from './axis'\nimport { DirectionType } from './direction'\nimport { Vector1DType } from './vector1d'\n\nexport type TranslateType = {\n  clear: () => void\n  to: (vector: Vector1DType) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(\n  axis: AxisType,\n  direction: DirectionType,\n  container: HTMLElement,\n): TranslateType {\n  const containerStyle = container.style\n  const translate = axis.scroll === 'x' ? x : y\n  let disabled = false\n\n  function x(n: number): string {\n    return `translate3d(${n}%,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}%,0px)`\n  }\n\n  function to(target: Vector1DType): void {\n    if (disabled) return\n    containerStyle.transform = translate(direction.applyTo(target.get()))\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    containerStyle.transform = ''\n  }\n\n  const self: TranslateType = {\n    clear,\n    to,\n    toggleActive,\n  }\n  return self\n}\n","import { Alignment } from './alignment'\nimport { Animation, AnimationType } from './animation'\nimport { Axis, AxisType } from './axis'\nimport { Counter, CounterType } from './counter'\nimport { Direction, DirectionType } from './direction'\nimport { DragHandler, DragHandlerType } from './dragHandler'\nimport { DragTracker } from './dragTracker'\nimport { EventEmitterType } from './eventEmitter'\nimport { Limit, LimitType } from './limit'\nimport { OptionsType } from './options'\nimport { PxToPercent, PxToPercentType } from './pxToPercent'\nimport { ScrollBody, ScrollBodyType } from './scrollBody'\nimport { ScrollBounds, ScrollBoundsType } from './scrollBounds'\nimport { ScrollContain } from './scrollContain'\nimport { ScrollLimit } from './scrollLimit'\nimport { ScrollLooper, ScrollLooperType } from './scrollLooper'\nimport { ScrollProgress, ScrollProgressType } from './scrollProgress'\nimport { ScrollSnap } from './scrollSnap'\nimport { ScrollTarget, ScrollTargetType } from './scrollTarget'\nimport { ScrollTo, ScrollToType } from './scrollTo'\nimport { SlideLooper, SlideLooperType } from './slideLooper'\nimport { SlideFocus, SlideFocusType } from './slideFocus'\nimport { SlidesInView, SlidesInViewType } from './slidesInView'\nimport { SlideSizes } from './slideSizes'\nimport { Translate, TranslateType } from './translate'\nimport { arrayKeys, arrayLast, lastIndex } from './utils'\nimport { Vector1D, Vector1DType } from './vector1d'\n\nexport type Engine = {\n  axis: AxisType\n  direction: DirectionType\n  animation: AnimationType\n  scrollBounds: ScrollBoundsType\n  scrollLooper: ScrollLooperType\n  scrollProgress: ScrollProgressType\n  index: CounterType\n  indexPrevious: CounterType\n  limit: LimitType\n  location: Vector1DType\n  options: OptionsType\n  pxToPercent: PxToPercentType\n  scrollBody: ScrollBodyType\n  dragHandler: DragHandlerType\n  slideFocus: SlideFocusType\n  slideLooper: SlideLooperType\n  slidesInView: SlidesInViewType\n  target: Vector1DType\n  translate: TranslateType\n  scrollTo: ScrollToType\n  scrollTarget: ScrollTargetType\n  scrollSnaps: number[]\n  slideIndexes: number[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: OptionsType,\n  events: EventEmitterType,\n): Engine {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction: contentDirection,\n    startIndex,\n    inViewThreshold,\n    loop,\n    speed,\n    dragFree,\n    slidesToScroll,\n    containScroll,\n  } = options\n\n  // Measurements\n  const containerRect = container.getBoundingClientRect()\n  const slideRects = slides.map((slide) => slide.getBoundingClientRect())\n  const direction = Direction(contentDirection)\n  const axis = Axis(scrollAxis, contentDirection)\n  const pxToPercent = PxToPercent(axis.measureSize(containerRect))\n  const viewSize = pxToPercent.totalPercent\n  const alignment = Alignment(align, viewSize)\n  const { slideSizes, slideSizesWithGaps } = SlideSizes(\n    axis,\n    pxToPercent,\n    slides,\n    slideRects,\n    loop,\n  )\n  const { snaps, snapsAligned } = ScrollSnap(\n    axis,\n    alignment,\n    pxToPercent,\n    containerRect,\n    slideRects,\n    slidesToScroll,\n  )\n  const contentSize = arrayLast(snaps) * -1 + arrayLast(slideSizesWithGaps)\n  const { snapsContained } = ScrollContain(\n    viewSize,\n    contentSize,\n    snaps,\n    snapsAligned,\n    containScroll,\n  )\n\n  const contain = !loop && containScroll !== ''\n  const scrollSnaps = contain ? snapsContained : snapsAligned\n  const { limit } = ScrollLimit(contentSize, scrollSnaps, loop)\n\n  // Indexes\n  const index = Counter(Limit(0, lastIndex(scrollSnaps)), loop, startIndex)\n  const indexPrevious = index.clone()\n  const slideIndexes = arrayKeys(slides)\n\n  // Draw\n  const update = (): void => {\n    if (!loop) {\n      engine.scrollBounds.constrain(target, engine.dragHandler.pointerDown())\n    }\n    engine.scrollBody.seek(target).update()\n    const settled = engine.scrollBody.settle(target)\n\n    if (settled && !engine.dragHandler.pointerDown()) {\n      engine.animation.stop()\n      events.emit('settle')\n    }\n    if (!settled) {\n      events.emit('scroll')\n    }\n    if (loop) {\n      engine.scrollLooper.loop(loopVectors, engine.scrollBody.direction())\n      engine.slideLooper.loop(slides)\n    }\n\n    engine.translate.to(location)\n    engine.animation.proceed()\n  }\n\n  // Shared\n  const animation = Animation(update)\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const loopVectors = [location, target]\n  const scrollBody = ScrollBody(location, speed, 1)\n  const scrollTarget = ScrollTarget(\n    index,\n    loop,\n    scrollSnaps,\n    contentSize,\n    limit,\n    target,\n  )\n  const scrollTo = ScrollTo(\n    animation,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n    events,\n  )\n  const slidesInView = SlidesInView(\n    viewSize,\n    contentSize,\n    slideSizes,\n    snaps,\n    loop,\n    inViewThreshold,\n  )\n\n  // DragHandler\n  const dragHandler = DragHandler(\n    axis,\n    direction,\n    root,\n    target,\n    dragFree,\n    DragTracker(axis, pxToPercent),\n    location,\n    animation,\n    scrollTo,\n    scrollBody,\n    scrollTarget,\n    index,\n    limit,\n    events,\n  )\n\n  // Slider\n  const engine: Engine = {\n    animation,\n    axis,\n    direction,\n    dragHandler,\n    pxToPercent,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    options,\n    scrollBody,\n    scrollBounds: ScrollBounds(limit, location, scrollBody),\n    scrollLooper: ScrollLooper(contentSize, pxToPercent, limit, location),\n    scrollProgress: ScrollProgress(limit),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideFocus: SlideFocus(root, scrollTo, slidesToScroll),\n    slideLooper: SlideLooper(\n      axis,\n      viewSize,\n      contentSize,\n      slideSizesWithGaps,\n      scrollSnaps,\n      slidesInView,\n      location,\n    ),\n    slidesInView,\n    slideIndexes,\n    target,\n    translate: Translate(axis, direction, container),\n  }\n  return engine\n}\n","export type PxToPercentType = {\n  measure: (n: number) => number\n  totalPercent: number\n}\n\nexport function PxToPercent(viewInPx: number): PxToPercentType {\n  const totalPercent = 100\n\n  function measure(n: number): number {\n    if (viewInPx === 0) return 0\n    return (n / viewInPx) * totalPercent\n  }\n\n  const self: PxToPercentType = {\n    measure,\n    totalPercent,\n  }\n  return self\n}\n","export type DirectionOptionType = 'ltr' | 'rtl'\n\nexport type DirectionType = {\n  applyTo: (n: number) => number\n}\n\nexport function Direction(direction: DirectionOptionType): DirectionType {\n  const sign = direction === 'rtl' ? -1 : 1\n\n  function applyTo(n: number): number {\n    return n * sign\n  }\n\n  const self: DirectionType = {\n    applyTo,\n  }\n  return self\n}\n","import { DirectionOptionType } from './direction'\n\nexport type AxisOptionType = 'x' | 'y'\ntype AxisEdgeType = 'top' | 'right' | 'bottom' | 'left'\n\nexport type AxisType = {\n  scroll: AxisOptionType\n  cross: AxisOptionType\n  startEdge: AxisEdgeType\n  endEdge: AxisEdgeType\n  measureSize: (rect: DOMRect) => number\n}\n\nexport function Axis(\n  axis: AxisOptionType,\n  contentDirection: DirectionOptionType,\n): AxisType {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n  const startEdge = getStartEdge()\n  const endEdge = getEndEdge()\n\n  function measureSize(rect: DOMRect): number {\n    const { width, height } = rect\n    return scroll === 'x' ? width : height\n  }\n\n  function getStartEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'top'\n    return contentDirection === 'rtl' ? 'right' : 'left'\n  }\n\n  function getEndEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'bottom'\n    return contentDirection === 'rtl' ? 'left' : 'right'\n  }\n\n  const self: AxisType = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n  }\n  return self\n}\n","import { AxisType } from './axis'\nimport { PxToPercentType } from './pxToPercent'\nimport { arrayLast, lastIndex } from './utils'\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n}\n\nexport function SlideSizes(\n  axis: AxisType,\n  pxToPercent: PxToPercentType,\n  slides: HTMLElement[],\n  slideRects: DOMRect[],\n  loop: boolean,\n): SlideSizesType {\n  const { measureSize, startEdge, endEdge } = axis\n  const sizesInPx = slideRects.map(measureSize)\n  const slideSizes = sizesInPx.map(pxToPercent.measure)\n  const slideSizesWithGaps = measureWithGaps()\n\n  function measureWithGaps(): number[] {\n    return slideRects\n      .map((rect, index, rects) => {\n        const isLast = index === lastIndex(rects)\n        const style = window.getComputedStyle(arrayLast(slides))\n        const endGap = parseFloat(style.getPropertyValue(`margin-${endEdge}`))\n        if (isLast) return sizesInPx[index] + (loop ? endGap : 0)\n        return rects[index + 1][startEdge] - rect[startEdge]\n      })\n      .map(pxToPercent.measure)\n      .map(Math.abs)\n  }\n\n  const self: SlideSizesType = {\n    slideSizes,\n    slideSizesWithGaps,\n  }\n  return self\n}\n","import { Limit, LimitType } from './limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollLimitType = {\n  limit: LimitType\n}\n\nexport function ScrollLimit(\n  contentSize: number,\n  scrollSnaps: number[],\n  loop: boolean,\n): ScrollLimitType {\n  const limit = measureLimit()\n\n  function measureLimit(): LimitType {\n    const startSnap = scrollSnaps[0]\n    const endSnap = arrayLast(scrollSnaps)\n    const min = loop ? startSnap - contentSize : endSnap\n    const max = startSnap\n    return Limit(min, max)\n  }\n\n  const self: ScrollLimitType = {\n    limit,\n  }\n  return self\n}\n","type CallbackType = () => void\n\nexport type AnimationType = {\n  start: () => void\n  stop: () => void\n  proceed: () => void\n}\n\nexport function Animation(callback: FrameRequestCallback): AnimationType {\n  let animationFrame = 0\n\n  function ifAnimating(active: boolean, cb: CallbackType): CallbackType {\n    return (): void => {\n      if (active === !!animationFrame) cb()\n    }\n  }\n\n  function start(): void {\n    animationFrame = window.requestAnimationFrame(callback)\n  }\n\n  function stop(): void {\n    window.cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n  }\n\n  const self: AnimationType = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop),\n  }\n  return self\n}\n","import { AnimationType } from './animation'\nimport { CounterType } from './counter'\nimport { EventEmitterType } from './eventEmitter'\nimport { ScrollTargetType, TargetType } from './scrollTarget'\nimport { Vector1DType } from './vector1d'\n\nexport type ScrollToType = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(\n  animation: AnimationType,\n  indexCurrent: CounterType,\n  indexPrevious: CounterType,\n  scrollTarget: ScrollTargetType,\n  targetVector: Vector1DType,\n  events: EventEmitterType,\n): ScrollToType {\n  function scrollTo(target: TargetType): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    if (distanceDiff) {\n      animation.start()\n      targetVector.add(distanceDiff)\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      events.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollToType = {\n    distance,\n    index,\n  }\n  return self\n}\n","type SlideBoundType = {\n  start: number\n  end: number\n  index: number\n}\n\nexport type SlidesInViewType = {\n  check: (location: number) => number[]\n  findSlideBounds: (offset: number, threshold?: number) => SlideBoundType[]\n}\n\nexport function SlidesInView(\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  snaps: number[],\n  loop: boolean,\n  inViewThreshold: number,\n): SlidesInViewType {\n  const threshold = Math.min(Math.max(inViewThreshold, 0.01), 0.99)\n  const offsets = loop ? [0, contentSize, -contentSize] : [0]\n  const slideBounds = offsets.reduce((a: SlideBoundType[], offset) => {\n    return a.concat(findSlideBounds(offset, threshold))\n  }, [])\n\n  function findSlideBounds(\n    offset: number,\n    threshold?: number,\n  ): SlideBoundType[] {\n    const thresholds = slideSizes.map((s) => s * (threshold || 0))\n    return snaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + thresholds[index] + offset,\n      end: snap + viewSize - thresholds[index] + offset,\n      index,\n    }))\n  }\n\n  function check(location: number): number[] {\n    return slideBounds.reduce((list: number[], slideBound) => {\n      const { index, start, end } = slideBound\n      const inList = list.indexOf(index) !== -1\n      const inView = start < location && end > location\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n\n  const self: SlidesInViewType = {\n    check,\n    findSlideBounds,\n  }\n  return self\n}\n","import { AxisOptionType, AxisType } from './axis'\nimport { PxToPercentType } from './pxToPercent'\nimport { Vector1D, Vector1DType } from './vector1d'\n\nexport type DragTrackerType = {\n  pointerDown: (evt: Event) => number\n  pointerMove: (evt: Event) => number\n  pointerUp: () => number\n  readPoint: (evt: any, axis: AxisOptionType) => Vector1DType\n}\n\nexport function DragTracker(\n  axis: AxisType,\n  pxToPercent: PxToPercentType,\n): DragTrackerType {\n  const { scroll: scrollAxis } = axis\n  const coords = { x: 'clientX', y: 'clientY' }\n  const startDrag = Vector1D(0)\n  const diffDrag = Vector1D(0)\n  const lastDrag = Vector1D(0)\n  const pointValue = Vector1D(0)\n  const trackInterval = 10\n  const trackLength = 5\n  const trackTime = 100\n  let trackPoints: number[] = []\n  let lastMoveTime = new Date().getTime()\n  let isMouse = false\n\n  function readPoint(evt: any, type: AxisOptionType): Vector1DType {\n    isMouse = !evt.touches\n    const c = coords[type]\n    const value = isMouse ? evt[c] : evt.touches[0][c]\n    return pointValue.set(value)\n  }\n\n  function pointerDown(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    startDrag.set(point)\n    lastDrag.set(point)\n    return pxToPercent.measure(startDrag.get())\n  }\n\n  function pointerMove(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n\n    if (diffTime >= trackInterval) {\n      if (diffTime >= trackTime) trackPoints = []\n      trackPoints.push(point.get())\n      lastMoveTime = nowTime\n    }\n\n    diffDrag.set(point).subtract(lastDrag)\n    lastDrag.set(point)\n    return pxToPercent.measure(diffDrag.get())\n  }\n\n  function pointerUp(): number {\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n    const currentPoint = lastDrag.get()\n\n    const force = trackPoints\n      .slice(-trackLength)\n      .map((trackPoint) => currentPoint - trackPoint)\n      .sort((p1, p2) => (Math.abs(p1) < Math.abs(p2) ? 1 : -1))[0]\n\n    lastDrag.set(diffTime > trackTime || !force ? 0 : force)\n    trackPoints = []\n    return pxToPercent.measure(lastDrag.get())\n  }\n\n  const self: DragTrackerType = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint,\n  }\n  return self\n}\n","import { AlignmentOptionType } from './alignment'\nimport { AxisOptionType } from './axis'\nimport { DirectionOptionType } from './direction'\nimport { ScrollContainOptionType } from './scrollContain'\n\nexport type OptionsType = {\n  align: AlignmentOptionType\n  axis: AxisOptionType\n  containScroll: ScrollContainOptionType\n  direction: DirectionOptionType\n  dragFree: boolean\n  draggable: boolean\n  draggableClass: string\n  draggingClass: string\n  inViewThreshold: number\n  loop: boolean\n  selectedClass: string\n  slidesToScroll: number\n  speed: number\n  startIndex: number\n}\n\nexport const defaultOptions: OptionsType = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  direction: 'ltr',\n  dragFree: false,\n  draggable: true,\n  draggableClass: 'is-draggable',\n  draggingClass: 'is-dragging',\n  inViewThreshold: 0,\n  loop: false,\n  selectedClass: 'is-selected',\n  slidesToScroll: 1,\n  speed: 10,\n  startIndex: 0,\n}\n\nexport type EmblaOptionsType = Partial<OptionsType>\n","import { Engine } from './components/engine'\nimport { EventStore } from './components/eventStore'\nimport { defaultOptions, EmblaOptionsType } from './components/options'\nimport { OptionsPseudo, OptionsPseudoType } from './components/optionsPseudo'\nimport { addClass, debounce, removeClass } from './components/utils'\nimport {\n  EventEmitter,\n  EmblaEventType,\n  EventEmitterType,\n} from './components/eventEmitter'\n\nexport type EmblaCarouselType = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  clickAllowed: () => boolean\n  containerNode: () => HTMLElement\n  dangerouslyGetEngine: () => Engine\n  destroy: () => void\n  off: EventEmitterType['off']\n  on: EventEmitterType['on']\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptionsType) => void\n  rootNode: () => HTMLElement\n  scrollNext: () => void\n  scrollPrev: () => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: (target?: boolean) => number[]\n  slidesNotInView: (target?: boolean) => number[]\n}\n\nfunction EmblaCarousel(\n  sliderRoot: HTMLElement,\n  userOptions?: EmblaOptionsType,\n): EmblaCarouselType {\n  const events = EventEmitter()\n  const eventStore = EventStore()\n  const debouncedResize = debounce(resize, 500)\n  const reInit = reActivate\n  const { on, off } = events\n\n  let engine: Engine\n  let activated = false\n  let options = Object.assign({}, defaultOptions)\n  let optionsPseudo: OptionsPseudoType\n  let rootNodeSize = 0\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  activate(userOptions)\n\n  function setupElements(): void {\n    if (!sliderRoot) throw new Error('Missing root node ')\n\n    const sliderContainer = sliderRoot.querySelector('*')\n    if (!sliderContainer) throw new Error('Missing container node ')\n\n    container = sliderContainer as HTMLElement\n    slides = Array.prototype.slice.call(container.children)\n    optionsPseudo = OptionsPseudo(sliderRoot)\n  }\n\n  function activate(partialOptions?: EmblaOptionsType): void {\n    setupElements()\n    options = Object.assign(options, partialOptions, optionsPseudo.get())\n    engine = Engine(sliderRoot, container, slides, options, events)\n    eventStore.add(window, 'resize', debouncedResize)\n    engine.translate.to(engine.location)\n    rootNodeSize = engine.axis.measureSize(sliderRoot.getBoundingClientRect())\n\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate()\n        return activate({ loop: false })\n      }\n      engine.slideLooper.loop(slides)\n    }\n    if (options.draggable && container.offsetParent && slides.length) {\n      engine.dragHandler.addActivationEvents()\n      if (options.draggableClass) {\n        addClass(sliderRoot, options.draggableClass)\n      }\n      if (options.draggingClass) {\n        events\n          .on('pointerDown', toggleDraggingClass)\n          .on('pointerUp', toggleDraggingClass)\n      }\n    }\n    if (slides.length) {\n      engine.slideFocus.addActivationEvents(slides)\n    }\n    if (options.selectedClass) {\n      toggleSelectedClass()\n      events\n        .on('select', toggleSelectedClass)\n        .on('pointerUp', toggleSelectedClass)\n    }\n    if (!activated) {\n      setTimeout(() => events.emit('init'), 0)\n      activated = true\n    }\n  }\n\n  function toggleDraggingClass(evt: EmblaEventType): void {\n    const { draggingClass } = options\n    if (evt === 'pointerDown') addClass(sliderRoot, draggingClass)\n    else removeClass(sliderRoot, draggingClass)\n  }\n\n  function toggleSelectedClass(): void {\n    const { selectedClass } = options\n    const inView = slidesInView(true)\n    const notInView = slidesNotInView(true)\n    notInView.forEach((index) => removeClass(slides[index], selectedClass))\n    inView.forEach((index) => addClass(slides[index], selectedClass))\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.removeAllEvents()\n    engine.slideFocus.removeAllEvents()\n    engine.animation.stop()\n    eventStore.removeAll()\n    engine.translate.clear()\n    engine.slideLooper.clear(slides)\n    removeClass(sliderRoot, options.draggableClass)\n    slides.forEach((slide) => removeClass(slide, options.selectedClass))\n    events.off('select', toggleSelectedClass)\n    events.off('pointerUp', toggleSelectedClass)\n    events.off('pointerDown', toggleDraggingClass)\n    events.off('pointerUp', toggleDraggingClass)\n  }\n\n  function reActivate(partialOptions?: EmblaOptionsType): void {\n    if (!activated) return\n    const startIndex = selectedScrollSnap()\n    const newOptions = Object.assign({ startIndex }, partialOptions)\n    deActivate()\n    activate(newOptions)\n    events.emit('reInit')\n  }\n\n  function destroy(): void {\n    if (!activated) return\n    deActivate()\n    activated = false\n    events.emit('destroy')\n  }\n\n  function resize(): void {\n    if (!activated) return\n    const size = engine.axis.measureSize(sliderRoot.getBoundingClientRect())\n    if (rootNodeSize !== size) reActivate()\n    events.emit('resize')\n  }\n\n  function slidesInView(target?: boolean): number[] {\n    const location = engine[target ? 'target' : 'location'].get()\n    const type = options.loop ? 'removeOffset' : 'constrain'\n    return engine.slidesInView.check(engine.limit[type](location))\n  }\n\n  function slidesNotInView(target?: boolean): number[] {\n    const inView = slidesInView(target)\n    return engine.slideIndexes.filter((index) => inView.indexOf(index) === -1)\n  }\n\n  function scrollTo(index: number, direction?: number): void {\n    engine.scrollBody.useBaseMass().useBaseSpeed()\n    if (activated) engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(): void {\n    const next = engine.index.clone().add(1)\n    scrollTo(next.get(), -1)\n  }\n\n  function scrollPrev(): void {\n    const prev = engine.index.clone().add(-1)\n    scrollTo(prev.get(), 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.clone().add(1)\n    return next.get() !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.clone().add(-1)\n    return prev.get() !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnaps.map(engine.scrollProgress.get)\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function clickAllowed(): boolean {\n    return engine.dragHandler.clickAllowed()\n  }\n\n  function dangerouslyGetEngine(): Engine {\n    return engine\n  }\n\n  function rootNode(): HTMLElement {\n    return sliderRoot\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarouselType = {\n    canScrollNext,\n    canScrollPrev,\n    clickAllowed,\n    containerNode,\n    dangerouslyGetEngine,\n    destroy,\n    off,\n    on,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView,\n  }\n  return self\n}\n\nexport default EmblaCarousel\n","type CallbackType = (evt: EmblaEventType) => void\ntype ListenersType = Partial<{ [key in EmblaEventType]: CallbackType[] }>\n\nexport type EmblaEventType =\n  | 'init'\n  | 'pointerDown'\n  | 'pointerUp'\n  | 'scroll'\n  | 'select'\n  | 'settle'\n  | 'destroy'\n  | 'reInit'\n  | 'resize'\n\nexport type EventEmitterType = {\n  emit: (evt: EmblaEventType) => EventEmitterType\n  on: (evt: EmblaEventType, cb: CallbackType) => EventEmitterType\n  off: (evt: EmblaEventType, cb: CallbackType) => EventEmitterType\n}\n\nexport function EventEmitter(): EventEmitterType {\n  const listeners: ListenersType = {}\n\n  function getListeners(evt: EmblaEventType): CallbackType[] {\n    const eventListeners = listeners[evt]\n    return eventListeners || []\n  }\n\n  function emit(evt: EmblaEventType): EventEmitterType {\n    getListeners(evt).forEach((e) => e(evt))\n    return self\n  }\n\n  function on(evt: EmblaEventType, cb: CallbackType): EventEmitterType {\n    listeners[evt] = getListeners(evt).concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEventType, cb: CallbackType): EventEmitterType {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb)\n    return self\n  }\n\n  const self: EventEmitterType = {\n    emit,\n    off,\n    on,\n  }\n  return self\n}\n","import { EmblaOptionsType } from './options'\n\nexport type OptionsPseudoType = {\n  get: () => EmblaOptionsType\n}\n\nexport function OptionsPseudo(node: HTMLElement): OptionsPseudoType {\n  const psuedoString = window.getComputedStyle(node, ':before').content\n\n  function get(): EmblaOptionsType {\n    try {\n      return JSON.parse(psuedoString.slice(1, -1).replace(/\\\\/g, ''))\n    } catch (error) {} // eslint-disable-line no-empty\n    return {}\n  }\n\n  const self: OptionsPseudoType = {\n    get,\n  }\n  return self\n}\n","import { useRef, useEffect, useState, useMemo } from 'react'\nimport EmblaCarousel, { EmblaCarouselType } from '../vanilla'\nimport { EmblaOptionsType } from '../vanilla/components/options'\nimport { areEqualShallow, canUseDOM } from './utils'\n\ntype ViewportRefType = <ViewportElement extends HTMLElement>(\n  instance: ViewportElement | null,\n) => void\n\nexport type UseEmblaCarouselType = [\n  ViewportRefType,\n  EmblaCarouselType | undefined,\n]\n\nfunction useEmblaCarousel(\n  options: EmblaOptionsType = {},\n): UseEmblaCarouselType {\n  const [embla, setEmbla] = useState<EmblaCarouselType>()\n  const [viewport, setViewport] = useState<HTMLElement>()\n  const storedOptions = useRef<EmblaOptionsType>(options)\n  const activeOptions = useMemo<EmblaOptionsType>(() => {\n    if (!areEqualShallow(storedOptions.current, options)) {\n      storedOptions.current = options\n    }\n    return storedOptions.current\n  }, [storedOptions, options])\n\n  useEffect(() => {\n    if (canUseDOM() && viewport) {\n      const newEmbla = EmblaCarousel(viewport, activeOptions)\n      setEmbla(newEmbla)\n      return () => newEmbla.destroy()\n    } else {\n      setEmbla(undefined)\n    }\n  }, [viewport, activeOptions, setEmbla])\n\n  return [setViewport as ViewportRefType, embla]\n}\n\nexport { useEmblaCarousel }\n","export function canUseDOM(): boolean {\n  return !!(\n    typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport function areEqualShallow(\n  objectA: { [key: string]: any },\n  objectB: { [key: string]: any },\n): boolean {\n  return (\n    Object.keys(objectA).length === Object.keys(objectB).length &&\n    Object.keys(objectA).every((objectKey) => {\n      if (!Object.prototype.hasOwnProperty.call(objectB, objectKey)) {\n        return false\n      }\n      return objectA[objectKey] === objectB[objectKey]\n    })\n  )\n}\n","/**\n * The base implementation of `_.sum` and `_.sumBy` without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {number} Returns the sum.\n */\nfunction baseSum(array, iteratee) {\n  var result,\n      index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var current = iteratee(array[index]);\n    if (current !== undefined) {\n      result = result === undefined ? current : (result + current);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseSum;\n"],"sourceRoot":""}